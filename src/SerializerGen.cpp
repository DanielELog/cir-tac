/* Autogenerated by mlir-tblgen; don't manually edit. */

#include "cir-tac/EnumsSerializer.h"
#include "cir-tac/Serializer.h"

#include <llvm/ADT/TypeSwitch.h>

using namespace protocir;

protocir::CIROp Serializer::serializeOperation(mlir::Operation &inst,
                                               protocir::CIRModuleID pModuleID,
                                               TypeCache &typeCache,
                                               OperationCache &opCache,
                                               BlockCache &blockCache) {
  protocir::CIROp pInst;

  auto resultTypes = inst.getResultTypes();
  for (const auto &resultType : resultTypes) {
    auto resultTypeID = internType(typeCache, resultType);
    pInst.add_result_types()->set_id(resultTypeID);
  }

  auto instID = internOperation(opCache, &inst);
  llvm::TypeSwitch<mlir::Operation *>(&inst)

      .Case<cir::AbsOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::AbsOp op) {
        protocir::CIRAbsOp pAbsOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAbsOp.mutable_src() = srcValue;

        auto poison = op.getPoison();
        pAbsOp.set_poison(poison);

        pInst.mutable_abs_op()->CopyFrom(pAbsOp);
      })

      .Case<cir::AllocExceptionOp>([instID, &pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::AllocExceptionOp op) {
        protocir::CIRAllocExceptionOp pAllocExceptionOp;
        pInst.mutable_base()->set_id(instID);

        auto size = op.getSize();
        pAllocExceptionOp.set_size(size);

        pInst.mutable_alloc_exception_op()->CopyFrom(pAllocExceptionOp);
      })

      .Case<cir::AllocaOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::AllocaOp op) {
        protocir::CIRAllocaOp pAllocaOp;
        pInst.mutable_base()->set_id(instID);

        auto dynAllocSizeRaw = op.getDynAllocSize();
        if (dynAllocSizeRaw) {
          auto dynAllocSizeValue = Serializer::serializeValue(
              dynAllocSizeRaw, pModuleID, typeCache, opCache, blockCache);
          *pAllocaOp.mutable_dyn_alloc_size() = dynAllocSizeValue;
        }

        auto allocaType = op.getAllocaType();
        auto allocaTypeID = internType(typeCache, allocaType);

        protocir::CIRTypeID pallocaTypeID;
        pallocaTypeID.set_id(allocaTypeID);

        *pAllocaOp.mutable_alloca_type() = pallocaTypeID;

        auto name = op.getName();
        *pAllocaOp.mutable_name() = name;

        auto init = op.getInit();
        pAllocaOp.set_init(init);

        auto constant = op.getConstant();
        pAllocaOp.set_constant(constant);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pAllocaOp.set_alignment(alignment);
        }

        pInst.mutable_alloca_op()->CopyFrom(pAllocaOp);
      })

      .Case<cir::ArrayCtor>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ArrayCtor op) {
        protocir::CIRArrayCtor pArrayCtor;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pArrayCtor.mutable_addr() = addrValue;

        pInst.mutable_array_ctor()->CopyFrom(pArrayCtor);
      })

      .Case<cir::ArrayDtor>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ArrayDtor op) {
        protocir::CIRArrayDtor pArrayDtor;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pArrayDtor.mutable_addr() = addrValue;

        pInst.mutable_array_dtor()->CopyFrom(pArrayDtor);
      })

      .Case<cir::AssumeAlignedOp>([instID, &pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::AssumeAlignedOp op) {
        protocir::CIRAssumeAlignedOp pAssumeAlignedOp;
        pInst.mutable_base()->set_id(instID);

        auto pointer = op.getPointer();
        auto pointerValue = Serializer::serializeValue(
            pointer, pModuleID, typeCache, opCache, blockCache);
        *pAssumeAlignedOp.mutable_pointer() = pointerValue;

        auto offsetRaw = op.getOffset();
        if (offsetRaw) {
          auto offsetValue = Serializer::serializeValue(
              offsetRaw, pModuleID, typeCache, opCache, blockCache);
          *pAssumeAlignedOp.mutable_offset() = offsetValue;
        }

        auto alignment = op.getAlignment();
        pAssumeAlignedOp.set_alignment(alignment);

        pInst.mutable_assume_aligned_op()->CopyFrom(pAssumeAlignedOp);
      })

      .Case<cir::AssumeOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::AssumeOp op) {
        protocir::CIRAssumeOp pAssumeOp;
        pInst.mutable_base()->set_id(instID);

        auto predicate = op.getPredicate();
        auto predicateValue = Serializer::serializeValue(
            predicate, pModuleID, typeCache, opCache, blockCache);
        *pAssumeOp.mutable_predicate() = predicateValue;

        pInst.mutable_assume_op()->CopyFrom(pAssumeOp);
      })

      .Case<cir::AssumeSepStorageOp>([instID, &pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::AssumeSepStorageOp op) {
        protocir::CIRAssumeSepStorageOp pAssumeSepStorageOp;
        pInst.mutable_base()->set_id(instID);

        auto ptr1 = op.getPtr1();
        auto ptr1Value = Serializer::serializeValue(ptr1, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pAssumeSepStorageOp.mutable_ptr1() = ptr1Value;

        auto ptr2 = op.getPtr2();
        auto ptr2Value = Serializer::serializeValue(ptr2, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pAssumeSepStorageOp.mutable_ptr2() = ptr2Value;

        pInst.mutable_assume_sep_storage_op()->CopyFrom(pAssumeSepStorageOp);
      })

      .Case<cir::AtomicCmpXchg>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::AtomicCmpXchg op) {
        protocir::CIRAtomicCmpXchg pAtomicCmpXchg;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAtomicCmpXchg.mutable_ptr() = ptrValue;

        auto expected = op.getExpected();
        auto expectedValue = Serializer::serializeValue(
            expected, pModuleID, typeCache, opCache, blockCache);
        *pAtomicCmpXchg.mutable_expected() = expectedValue;

        auto desired = op.getDesired();
        auto desiredValue = Serializer::serializeValue(
            desired, pModuleID, typeCache, opCache, blockCache);
        *pAtomicCmpXchg.mutable_desired() = desiredValue;

        auto succOrder = op.getSuccOrder();
        auto psuccOrder = EnumSerializer::serializeMemOrder(succOrder);
        pAtomicCmpXchg.set_succ_order(psuccOrder);

        auto failOrder = op.getFailOrder();
        auto pfailOrder = EnumSerializer::serializeMemOrder(failOrder);
        pAtomicCmpXchg.set_fail_order(pfailOrder);

        auto weak = op.getWeak();
        pAtomicCmpXchg.set_weak(weak);

        auto isVolatile = op.getIsVolatile();
        pAtomicCmpXchg.set_is_volatile(isVolatile);

        pInst.mutable_atomic_cmp_xchg()->CopyFrom(pAtomicCmpXchg);
      })

      .Case<cir::AtomicFetch>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::AtomicFetch op) {
        protocir::CIRAtomicFetch pAtomicFetch;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAtomicFetch.mutable_ptr() = ptrValue;

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAtomicFetch.mutable_val() = valValue;

        auto binop = op.getBinop();
        auto pbinop = EnumSerializer::serializeAtomicFetchKind(binop);
        pAtomicFetch.set_binop(pbinop);

        auto memOrder = op.getMemOrder();
        auto pmemOrder = EnumSerializer::serializeMemOrder(memOrder);
        pAtomicFetch.set_mem_order(pmemOrder);

        auto isVolatile = op.getIsVolatile();
        pAtomicFetch.set_is_volatile(isVolatile);

        auto fetchFirst = op.getFetchFirst();
        pAtomicFetch.set_fetch_first(fetchFirst);

        pInst.mutable_atomic_fetch()->CopyFrom(pAtomicFetch);
      })

      .Case<cir::AtomicXchg>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::AtomicXchg op) {
        protocir::CIRAtomicXchg pAtomicXchg;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAtomicXchg.mutable_ptr() = ptrValue;

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pAtomicXchg.mutable_val() = valValue;

        auto memOrder = op.getMemOrder();
        auto pmemOrder = EnumSerializer::serializeMemOrder(memOrder);
        pAtomicXchg.set_mem_order(pmemOrder);

        auto isVolatile = op.getIsVolatile();
        pAtomicXchg.set_is_volatile(isVolatile);

        pInst.mutable_atomic_xchg()->CopyFrom(pAtomicXchg);
      })

      .Case<cir::AwaitOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::AwaitOp op) {
        protocir::CIRAwaitOp pAwaitOp;
        pInst.mutable_base()->set_id(instID);

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeAwaitKind(kind);
        pAwaitOp.set_kind(pkind);

        pInst.mutable_await_op()->CopyFrom(pAwaitOp);
      })

      .Case<cir::BaseClassAddrOp>([instID, &pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::BaseClassAddrOp op) {
        protocir::CIRBaseClassAddrOp pBaseClassAddrOp;
        pInst.mutable_base()->set_id(instID);

        auto derivedAddr = op.getDerivedAddr();
        auto derivedAddrValue = Serializer::serializeValue(
            derivedAddr, pModuleID, typeCache, opCache, blockCache);
        *pBaseClassAddrOp.mutable_derived_addr() = derivedAddrValue;

        llvm::SmallVector<char> offsetStr;
        auto offset = op.getOffset();
        offset.toString(offsetStr, 10, false);
        llvm::StringRef offsetStrRef(offsetStr.data(), offsetStr.size());
        *pBaseClassAddrOp.mutable_offset() = offsetStrRef;

        auto assumeNotNull = op.getAssumeNotNull();
        pBaseClassAddrOp.set_assume_not_null(assumeNotNull);

        pInst.mutable_base_class_addr_op()->CopyFrom(pBaseClassAddrOp);
      })

      .Case<cir::BinOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::BinOp op) {
        protocir::CIRBinOp pBinOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pBinOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pBinOp.mutable_rhs() = rhsValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeBinOpKind(kind);
        pBinOp.set_kind(pkind);

        auto noUnsignedWrap = op.getNoUnsignedWrap();
        pBinOp.set_no_unsigned_wrap(noUnsignedWrap);

        auto noSignedWrap = op.getNoSignedWrap();
        pBinOp.set_no_signed_wrap(noSignedWrap);

        pInst.mutable_bin_op()->CopyFrom(pBinOp);
      })

      .Case<cir::BinOpOverflowOp>([instID, &pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::BinOpOverflowOp op) {
        protocir::CIRBinOpOverflowOp pBinOpOverflowOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pBinOpOverflowOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pBinOpOverflowOp.mutable_rhs() = rhsValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeBinOpOverflowKind(kind);
        pBinOpOverflowOp.set_kind(pkind);

        pInst.mutable_bin_op_overflow_op()->CopyFrom(pBinOpOverflowOp);
      })

      .Case<cir::BitClrsbOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::BitClrsbOp op) {
        protocir::CIRBitClrsbOp pBitClrsbOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitClrsbOp.mutable_input() = inputValue;

        pInst.mutable_bit_clrsb_op()->CopyFrom(pBitClrsbOp);
      })

      .Case<cir::BitClzOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitClzOp op) {
        protocir::CIRBitClzOp pBitClzOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitClzOp.mutable_input() = inputValue;

        pInst.mutable_bit_clz_op()->CopyFrom(pBitClzOp);
      })

      .Case<cir::BitCtzOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitCtzOp op) {
        protocir::CIRBitCtzOp pBitCtzOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitCtzOp.mutable_input() = inputValue;

        pInst.mutable_bit_ctz_op()->CopyFrom(pBitCtzOp);
      })

      .Case<cir::BitFfsOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitFfsOp op) {
        protocir::CIRBitFfsOp pBitFfsOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitFfsOp.mutable_input() = inputValue;

        pInst.mutable_bit_ffs_op()->CopyFrom(pBitFfsOp);
      })

      .Case<cir::BitParityOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::BitParityOp op) {
        protocir::CIRBitParityOp pBitParityOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitParityOp.mutable_input() = inputValue;

        pInst.mutable_bit_parity_op()->CopyFrom(pBitParityOp);
      })

      .Case<cir::BitPopcountOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::BitPopcountOp op) {
        protocir::CIRBitPopcountOp pBitPopcountOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pBitPopcountOp.mutable_input() = inputValue;

        pInst.mutable_bit_popcount_op()->CopyFrom(pBitPopcountOp);
      })

      .Case<cir::BrCondOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BrCondOp op) {
        protocir::CIRBrCondOp pBrCondOp;
        pInst.mutable_base()->set_id(instID);

        auto cond = op.getCond();
        auto condValue = Serializer::serializeValue(cond, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pBrCondOp.mutable_cond() = condValue;

        auto destOperandsTrue = op.getDestOperandsTrue();
        for (auto edestOperandsTrue : destOperandsTrue) {
          auto edestOperandsTrueProto = pBrCondOp.add_dest_operands_true();
          auto edestOperandsTrueValue = Serializer::serializeValue(
              edestOperandsTrue, pModuleID, typeCache, opCache, blockCache);
          edestOperandsTrueProto->CopyFrom(edestOperandsTrueValue);
        }

        auto destOperandsFalse = op.getDestOperandsFalse();
        for (auto edestOperandsFalse : destOperandsFalse) {
          auto edestOperandsFalseProto = pBrCondOp.add_dest_operands_false();
          auto edestOperandsFalseValue = Serializer::serializeValue(
              edestOperandsFalse, pModuleID, typeCache, opCache, blockCache);
          edestOperandsFalseProto->CopyFrom(edestOperandsFalseValue);
        }

        auto destTrue = op.getDestTrue();
        auto destTrueID = internBlock(blockCache, destTrue);
        protocir::CIRBlockID pdestTrueID;
        pdestTrueID.set_id(destTrueID);

        *pBrCondOp.mutable_dest_true() = pdestTrueID;

        auto destFalse = op.getDestFalse();
        auto destFalseID = internBlock(blockCache, destFalse);
        protocir::CIRBlockID pdestFalseID;
        pdestFalseID.set_id(destFalseID);

        *pBrCondOp.mutable_dest_false() = pdestFalseID;

        pInst.mutable_br_cond_op()->CopyFrom(pBrCondOp);
      })

      .Case<cir::BrOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                        &opCache](cir::BrOp op) {
        protocir::CIRBrOp pBrOp;
        pInst.mutable_base()->set_id(instID);

        auto destOperands = op.getDestOperands();
        for (auto edestOperands : destOperands) {
          auto edestOperandsProto = pBrOp.add_dest_operands();
          auto edestOperandsValue = Serializer::serializeValue(
              edestOperands, pModuleID, typeCache, opCache, blockCache);
          edestOperandsProto->CopyFrom(edestOperandsValue);
        }

        auto dest = op.getDest();
        auto destID = internBlock(blockCache, dest);
        protocir::CIRBlockID pdestID;
        pdestID.set_id(destID);

        *pBrOp.mutable_dest() = pdestID;

        pInst.mutable_br_op()->CopyFrom(pBrOp);
      })

      .Case<cir::BreakOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::BreakOp op) {
        protocir::CIRBreakOp pBreakOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_break_op()->CopyFrom(pBreakOp);
      })

      .Case<cir::ByteswapOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::ByteswapOp op) {
        protocir::CIRByteswapOp pByteswapOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pByteswapOp.mutable_input() = inputValue;

        pInst.mutable_byteswap_op()->CopyFrom(pByteswapOp);
      })

      .Case<cir::InlineAsmOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::InlineAsmOp op) {
        protocir::CIRInlineAsmOp pInlineAsmOp;
        pInst.mutable_base()->set_id(instID);

        auto operands = op.getOperands();
        for (auto eoperands : operands) {
          auto eoperandsProto = pInlineAsmOp.add_operands();
          for (auto eeoperands : eoperands) {
            auto eeoperandsProto = eoperandsProto->add_range();
            auto eeoperandsValue = Serializer::serializeValue(
                eeoperands, pModuleID, typeCache, opCache, blockCache);
            eeoperandsProto->CopyFrom(eeoperandsValue);
          }
        }

        auto asmString = op.getAsmString();
        *pInlineAsmOp.mutable_asm_string() = asmString;

        auto constraints = op.getConstraints();
        *pInlineAsmOp.mutable_constraints() = constraints;

        auto sideEffects = op.getSideEffects();
        pInlineAsmOp.set_side_effects(sideEffects);

        auto asmFlavor = op.getAsmFlavor();
        auto pasmFlavor = EnumSerializer::serializeAsmFlavor(asmFlavor);
        pInlineAsmOp.set_asm_flavor(pasmFlavor);

        auto operandsSegments = op.getOperandsSegments();
        for (auto eoperandsSegments : operandsSegments) {
          pInlineAsmOp.add_operands_segments(eoperandsSegments);
        }

        pInst.mutable_inline_asm_op()->CopyFrom(pInlineAsmOp);
      })

      .Case<cir::CallOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CallOp op) {
        protocir::CIRCallOp pCallOp;
        pInst.mutable_base()->set_id(instID);

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pCallOp.add_arg_ops();
          auto eargOpsValue = Serializer::serializeValue(
              eargOps, pModuleID, typeCache, opCache, blockCache);
          eargOpsProto->CopyFrom(eargOpsValue);
        }

        auto exception = op.getException();
        pCallOp.set_exception(exception);

        auto calleeOptional = op.getCallee();
        if (calleeOptional) {
          auto callee = calleeOptional.value();
          *pCallOp.mutable_callee() = callee;
        }

        auto callingConv = op.getCallingConv();
        auto pcallingConv = EnumSerializer::serializeCallingConv(callingConv);
        pCallOp.set_calling_conv(pcallingConv);

        pInst.mutable_call_op()->CopyFrom(pCallOp);
      })

      .Case<cir::CaseOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CaseOp op) {
        protocir::CIRCaseOp pCaseOp;
        pInst.mutable_base()->set_id(instID);

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeCaseOpKind(kind);
        pCaseOp.set_kind(pkind);

        pInst.mutable_case_op()->CopyFrom(pCaseOp);
      })

      .Case<cir::CastOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CastOp op) {
        protocir::CIRCastOp pCastOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCastOp.mutable_src() = srcValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeCastKind(kind);
        pCastOp.set_kind(pkind);

        pInst.mutable_cast_op()->CopyFrom(pCastOp);
      })

      .Case<cir::CatchParamOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::CatchParamOp op) {
        protocir::CIRCatchParamOp pCatchParamOp;
        pInst.mutable_base()->set_id(instID);

        auto exceptionPtrRaw = op.getExceptionPtr();
        if (exceptionPtrRaw) {
          auto exceptionPtrValue = Serializer::serializeValue(
              exceptionPtrRaw, pModuleID, typeCache, opCache, blockCache);
          *pCatchParamOp.mutable_exception_ptr() = exceptionPtrValue;
        }

        auto kindOptional = op.getKind();
        if (kindOptional) {
          auto kind = kindOptional.value();
          auto pkind = EnumSerializer::serializeCatchParamKind(kind);
          pCatchParamOp.set_kind(pkind);
        }

        pInst.mutable_catch_param_op()->CopyFrom(pCatchParamOp);
      })

      .Case<cir::CeilOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CeilOp op) {
        protocir::CIRCeilOp pCeilOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCeilOp.mutable_src() = srcValue;

        pInst.mutable_ceil_op()->CopyFrom(pCeilOp);
      })

      .Case<cir::ClearCacheOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ClearCacheOp op) {
        protocir::CIRClearCacheOp pClearCacheOp;
        pInst.mutable_base()->set_id(instID);

        auto begin = op.getBegin();
        auto beginValue = Serializer::serializeValue(
            begin, pModuleID, typeCache, opCache, blockCache);
        *pClearCacheOp.mutable_begin() = beginValue;

        auto end = op.getEnd();
        auto endValue = Serializer::serializeValue(end, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pClearCacheOp.mutable_end() = endValue;

        pInst.mutable_clear_cache_op()->CopyFrom(pClearCacheOp);
      })

      .Case<cir::CmpOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::CmpOp op) {
        protocir::CIRCmpOp pCmpOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCmpOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCmpOp.mutable_rhs() = rhsValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeCmpOpKind(kind);
        pCmpOp.set_kind(pkind);

        pInst.mutable_cmp_op()->CopyFrom(pCmpOp);
      })

      .Case<cir::CmpThreeWayOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::CmpThreeWayOp op) {
        protocir::CIRCmpThreeWayOp pCmpThreeWayOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCmpThreeWayOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCmpThreeWayOp.mutable_rhs() = rhsValue;

        pInst.mutable_cmp_three_way_op()->CopyFrom(pCmpThreeWayOp);
      })

      .Case<cir::ComplexBinOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ComplexBinOp op) {
        protocir::CIRComplexBinOp pComplexBinOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pComplexBinOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pComplexBinOp.mutable_rhs() = rhsValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeComplexBinOpKind(kind);
        pComplexBinOp.set_kind(pkind);

        auto range = op.getRange();
        auto prange = EnumSerializer::serializeComplexRangeKind(range);
        pComplexBinOp.set_range(prange);

        auto promoted = op.getPromoted();
        pComplexBinOp.set_promoted(promoted);

        pInst.mutable_complex_bin_op()->CopyFrom(pComplexBinOp);
      })

      .Case<cir::ComplexCreateOp>([instID, &pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::ComplexCreateOp op) {
        protocir::CIRComplexCreateOp pComplexCreateOp;
        pInst.mutable_base()->set_id(instID);

        auto real = op.getReal();
        auto realValue = Serializer::serializeValue(real, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pComplexCreateOp.mutable_real() = realValue;

        auto imag = op.getImag();
        auto imagValue = Serializer::serializeValue(imag, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pComplexCreateOp.mutable_imag() = imagValue;

        pInst.mutable_complex_create_op()->CopyFrom(pComplexCreateOp);
      })

      .Case<cir::ComplexImagOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::ComplexImagOp op) {
        protocir::CIRComplexImagOp pComplexImagOp;
        pInst.mutable_base()->set_id(instID);

        auto operand = op.getOperand();
        auto operandValue = Serializer::serializeValue(
            operand, pModuleID, typeCache, opCache, blockCache);
        *pComplexImagOp.mutable_operand() = operandValue;

        pInst.mutable_complex_imag_op()->CopyFrom(pComplexImagOp);
      })

      .Case<cir::ComplexImagPtrOp>([instID, &pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::ComplexImagPtrOp op) {
        protocir::CIRComplexImagPtrOp pComplexImagPtrOp;
        pInst.mutable_base()->set_id(instID);

        auto operand = op.getOperand();
        auto operandValue = Serializer::serializeValue(
            operand, pModuleID, typeCache, opCache, blockCache);
        *pComplexImagPtrOp.mutable_operand() = operandValue;

        pInst.mutable_complex_imag_ptr_op()->CopyFrom(pComplexImagPtrOp);
      })

      .Case<cir::ComplexRealOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::ComplexRealOp op) {
        protocir::CIRComplexRealOp pComplexRealOp;
        pInst.mutable_base()->set_id(instID);

        auto operand = op.getOperand();
        auto operandValue = Serializer::serializeValue(
            operand, pModuleID, typeCache, opCache, blockCache);
        *pComplexRealOp.mutable_operand() = operandValue;

        pInst.mutable_complex_real_op()->CopyFrom(pComplexRealOp);
      })

      .Case<cir::ComplexRealPtrOp>([instID, &pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::ComplexRealPtrOp op) {
        protocir::CIRComplexRealPtrOp pComplexRealPtrOp;
        pInst.mutable_base()->set_id(instID);

        auto operand = op.getOperand();
        auto operandValue = Serializer::serializeValue(
            operand, pModuleID, typeCache, opCache, blockCache);
        *pComplexRealPtrOp.mutable_operand() = operandValue;

        pInst.mutable_complex_real_ptr_op()->CopyFrom(pComplexRealPtrOp);
      })

      .Case<cir::ConditionOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::ConditionOp op) {
        protocir::CIRConditionOp pConditionOp;
        pInst.mutable_base()->set_id(instID);

        auto condition = op.getCondition();
        auto conditionValue = Serializer::serializeValue(
            condition, pModuleID, typeCache, opCache, blockCache);
        *pConditionOp.mutable_condition() = conditionValue;

        pInst.mutable_condition_op()->CopyFrom(pConditionOp);
      })

      .Case<cir::ConstantOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::ConstantOp op) {
        protocir::CIRConstantOp pConstantOp;
        pInst.mutable_base()->set_id(instID);

        std::string valueStr;
        llvm::raw_string_ostream valueRawStream(valueStr);
        op.getValue().print(valueRawStream);
        *pConstantOp.mutable_value() = valueStr;

        pInst.mutable_constant_op()->CopyFrom(pConstantOp);
      })

      .Case<cir::ContinueOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::ContinueOp op) {
        protocir::CIRContinueOp pContinueOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_continue_op()->CopyFrom(pContinueOp);
      })

      .Case<cir::CopyOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CopyOp op) {
        protocir::CIRCopyOp pCopyOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCopyOp.mutable_dst() = dstValue;

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCopyOp.mutable_src() = srcValue;

        auto isVolatile = op.getIsVolatile();
        pCopyOp.set_is_volatile(isVolatile);

        pInst.mutable_copy_op()->CopyFrom(pCopyOp);
      })

      .Case<cir::CopysignOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::CopysignOp op) {
        protocir::CIRCopysignOp pCopysignOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCopysignOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCopysignOp.mutable_rhs() = rhsValue;

        pInst.mutable_copysign_op()->CopyFrom(pCopysignOp);
      })

      .Case<cir::CosOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::CosOp op) {
        protocir::CIRCosOp pCosOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pCosOp.mutable_src() = srcValue;

        pInst.mutable_cos_op()->CopyFrom(pCosOp);
      })

      .Case<cir::DerivedClassAddrOp>([instID, &pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::DerivedClassAddrOp op) {
        protocir::CIRDerivedClassAddrOp pDerivedClassAddrOp;
        pInst.mutable_base()->set_id(instID);

        auto baseAddr = op.getBaseAddr();
        auto baseAddrValue = Serializer::serializeValue(
            baseAddr, pModuleID, typeCache, opCache, blockCache);
        *pDerivedClassAddrOp.mutable_base_addr() = baseAddrValue;

        llvm::SmallVector<char> offsetStr;
        auto offset = op.getOffset();
        offset.toString(offsetStr, 10, false);
        llvm::StringRef offsetStrRef(offsetStr.data(), offsetStr.size());
        *pDerivedClassAddrOp.mutable_offset() = offsetStrRef;

        auto assumeNotNull = op.getAssumeNotNull();
        pDerivedClassAddrOp.set_assume_not_null(assumeNotNull);

        pInst.mutable_derived_class_addr_op()->CopyFrom(pDerivedClassAddrOp);
      })

      .Case<cir::DoWhileOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::DoWhileOp op) {
        protocir::CIRDoWhileOp pDoWhileOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_do_while_op()->CopyFrom(pDoWhileOp);
      })

      .Case<cir::DynamicCastOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::DynamicCastOp op) {
        protocir::CIRDynamicCastOp pDynamicCastOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pDynamicCastOp.mutable_src() = srcValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeDynamicCastKind(kind);
        pDynamicCastOp.set_kind(pkind);

        auto relativeLayout = op.getRelativeLayout();
        pDynamicCastOp.set_relative_layout(relativeLayout);

        pInst.mutable_dynamic_cast_op()->CopyFrom(pDynamicCastOp);
      })

      .Case<cir::EhInflightOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::EhInflightOp op) {
        protocir::CIREhInflightOp pEhInflightOp;
        pInst.mutable_base()->set_id(instID);

        auto cleanup = op.getCleanup();
        pEhInflightOp.set_cleanup(cleanup);

        pInst.mutable_eh_inflight_op()->CopyFrom(pEhInflightOp);
      })

      .Case<cir::EhTypeIdOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::EhTypeIdOp op) {
        protocir::CIREhTypeIdOp pEhTypeIdOp;
        pInst.mutable_base()->set_id(instID);

        auto typeSym = op.getTypeSym();
        *pEhTypeIdOp.mutable_type_sym() = typeSym;

        pInst.mutable_eh_type_id_op()->CopyFrom(pEhTypeIdOp);
      })

      .Case<cir::Exp2Op>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::Exp2Op op) {
        protocir::CIRExp2Op pExp2Op;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pExp2Op.mutable_src() = srcValue;

        pInst.mutable_exp2_op()->CopyFrom(pExp2Op);
      })

      .Case<cir::ExpOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::ExpOp op) {
        protocir::CIRExpOp pExpOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pExpOp.mutable_src() = srcValue;

        pInst.mutable_exp_op()->CopyFrom(pExpOp);
      })

      .Case<cir::ExpectOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ExpectOp op) {
        protocir::CIRExpectOp pExpectOp;
        pInst.mutable_base()->set_id(instID);

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pExpectOp.mutable_val() = valValue;

        auto expected = op.getExpected();
        auto expectedValue = Serializer::serializeValue(
            expected, pModuleID, typeCache, opCache, blockCache);
        *pExpectOp.mutable_expected() = expectedValue;

        auto probOptional = op.getProb();
        if (probOptional) {
          auto prob = probOptional.value();
          llvm::SmallVector<char> probStr;
          prob.toString(probStr);
          llvm::StringRef probStrRef(probStr.data(), probStr.size());
          *pExpectOp.mutable_prob() = probStrRef;
        }

        pInst.mutable_expect_op()->CopyFrom(pExpectOp);
      })

      .Case<cir::FAbsOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FAbsOp op) {
        protocir::CIRFAbsOp pFAbsOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFAbsOp.mutable_src() = srcValue;

        pInst.mutable_f_abs_op()->CopyFrom(pFAbsOp);
      })

      .Case<cir::FMaxOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FMaxOp op) {
        protocir::CIRFMaxOp pFMaxOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFMaxOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFMaxOp.mutable_rhs() = rhsValue;

        pInst.mutable_f_max_op()->CopyFrom(pFMaxOp);
      })

      .Case<cir::FMinOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FMinOp op) {
        protocir::CIRFMinOp pFMinOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFMinOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFMinOp.mutable_rhs() = rhsValue;

        pInst.mutable_f_min_op()->CopyFrom(pFMinOp);
      })

      .Case<cir::FModOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FModOp op) {
        protocir::CIRFModOp pFModOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFModOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFModOp.mutable_rhs() = rhsValue;

        pInst.mutable_f_mod_op()->CopyFrom(pFModOp);
      })

      .Case<cir::FloorOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::FloorOp op) {
        protocir::CIRFloorOp pFloorOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFloorOp.mutable_src() = srcValue;

        pInst.mutable_floor_op()->CopyFrom(pFloorOp);
      })

      .Case<cir::ForOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::ForOp op) {
        protocir::CIRForOp pForOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_for_op()->CopyFrom(pForOp);
      })

      .Case<cir::FrameAddrOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::FrameAddrOp op) {
        protocir::CIRFrameAddrOp pFrameAddrOp;
        pInst.mutable_base()->set_id(instID);

        auto level = op.getLevel();
        auto levelValue = Serializer::serializeValue(
            level, pModuleID, typeCache, opCache, blockCache);
        *pFrameAddrOp.mutable_level() = levelValue;

        pInst.mutable_frame_addr_op()->CopyFrom(pFrameAddrOp);
      })

      .Case<cir::FreeExceptionOp>([instID, &pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::FreeExceptionOp op) {
        protocir::CIRFreeExceptionOp pFreeExceptionOp;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pFreeExceptionOp.mutable_ptr() = ptrValue;

        pInst.mutable_free_exception_op()->CopyFrom(pFreeExceptionOp);
      })

      .Case<cir::FuncOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FuncOp op) {
        protocir::CIRFuncOp pFuncOp;
        pInst.mutable_base()->set_id(instID);

        auto symName = op.getSymName();
        *pFuncOp.mutable_sym_name() = symName;

        auto globalVisibility = op.getGlobalVisibility().getValue();
        auto pglobalVisibility =
            EnumSerializer::serializeVisibilityKind(globalVisibility);
        pFuncOp.set_global_visibility(pglobalVisibility);

        auto functionType = op.getFunctionType();
        auto functionTypeID = internType(typeCache, functionType);

        protocir::CIRTypeID pfunctionTypeID;
        pfunctionTypeID.set_id(functionTypeID);

        *pFuncOp.mutable_function_type() = pfunctionTypeID;

        auto builtin = op.getBuiltin();
        pFuncOp.set_builtin(builtin);

        auto coroutine = op.getCoroutine();
        pFuncOp.set_coroutine(coroutine);

        auto lambda = op.getLambda();
        pFuncOp.set_lambda(lambda);

        auto noProto = op.getNoProto();
        pFuncOp.set_no_proto(noProto);

        auto dsolocal = op.getDsolocal();
        pFuncOp.set_dsolocal(dsolocal);

        auto linkage = op.getLinkage();
        auto plinkage = EnumSerializer::serializeGlobalLinkageKind(linkage);
        pFuncOp.set_linkage(plinkage);

        auto callingConv = op.getCallingConv();
        auto pcallingConv = EnumSerializer::serializeCallingConv(callingConv);
        pFuncOp.set_calling_conv(pcallingConv);

        auto symVisibilityOptional = op.getSymVisibility();
        if (symVisibilityOptional) {
          auto symVisibility = symVisibilityOptional.value();
          *pFuncOp.mutable_sym_visibility() = symVisibility;
        }

        auto comdat = op.getComdat();
        pFuncOp.set_comdat(comdat);

        auto aliaseeOptional = op.getAliasee();
        if (aliaseeOptional) {
          auto aliasee = aliaseeOptional.value();
          *pFuncOp.mutable_aliasee() = aliasee;
        }

        auto globalCtorOptional = op.getGlobalCtor();
        pFuncOp.set_global_ctor(globalCtorOptional.has_value());

        auto globalDtorOptional = op.getGlobalDtor();
        pFuncOp.set_global_dtor(globalDtorOptional.has_value());

        auto astOptional = op.getAst();
        if (astOptional) {
          auto ast = astOptional.value();

          std::string astStr;
          llvm::raw_string_ostream astRawStream(astStr);
          ast.print(astRawStream);
          *pFuncOp.mutable_ast() = astStr;
        }

        pInst.mutable_func_op()->CopyFrom(pFuncOp);
      })

      .Case<cir::GetBitfieldOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::GetBitfieldOp op) {
        protocir::CIRGetBitfieldOp pGetBitfieldOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pGetBitfieldOp.mutable_addr() = addrValue;

        auto isVolatile = op.getIsVolatile();
        pGetBitfieldOp.set_is_volatile(isVolatile);

        pInst.mutable_get_bitfield_op()->CopyFrom(pGetBitfieldOp);
      })

      .Case<cir::GetGlobalOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetGlobalOp op) {
        protocir::CIRGetGlobalOp pGetGlobalOp;
        pInst.mutable_base()->set_id(instID);

        auto name = op.getName();
        *pGetGlobalOp.mutable_name() = name;

        auto tls = op.getTls();
        pGetGlobalOp.set_tls(tls);

        pInst.mutable_get_global_op()->CopyFrom(pGetGlobalOp);
      })

      .Case<cir::GetMemberOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetMemberOp op) {
        protocir::CIRGetMemberOp pGetMemberOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pGetMemberOp.mutable_addr() = addrValue;

        auto name = op.getName();
        *pGetMemberOp.mutable_name() = name;

        llvm::SmallVector<char> indexAttrStr;
        auto indexAttr = op.getIndexAttr();
        indexAttr.toString(indexAttrStr, 10, false);
        llvm::StringRef indexAttrStrRef(indexAttrStr.data(),
                                        indexAttrStr.size());
        *pGetMemberOp.mutable_index_attr() = indexAttrStrRef;

        pInst.mutable_get_member_op()->CopyFrom(pGetMemberOp);
      })

      .Case<cir::GetMethodOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetMethodOp op) {
        protocir::CIRGetMethodOp pGetMethodOp;
        pInst.mutable_base()->set_id(instID);

        auto method = op.getMethod();
        auto methodValue = Serializer::serializeValue(
            method, pModuleID, typeCache, opCache, blockCache);
        *pGetMethodOp.mutable_method() = methodValue;

        auto object = op.getObject();
        auto objectValue = Serializer::serializeValue(
            object, pModuleID, typeCache, opCache, blockCache);
        *pGetMethodOp.mutable_object() = objectValue;

        pInst.mutable_get_method_op()->CopyFrom(pGetMethodOp);
      })

      .Case<cir::GetRuntimeMemberOp>([instID, &pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::GetRuntimeMemberOp op) {
        protocir::CIRGetRuntimeMemberOp pGetRuntimeMemberOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pGetRuntimeMemberOp.mutable_addr() = addrValue;

        auto member = op.getMember();
        auto memberValue = Serializer::serializeValue(
            member, pModuleID, typeCache, opCache, blockCache);
        *pGetRuntimeMemberOp.mutable_member() = memberValue;

        pInst.mutable_get_runtime_member_op()->CopyFrom(pGetRuntimeMemberOp);
      })

      .Case<cir::GlobalOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::GlobalOp op) {
        protocir::CIRGlobalOp pGlobalOp;
        pInst.mutable_base()->set_id(instID);

        auto symName = op.getSymName();
        *pGlobalOp.mutable_sym_name() = symName;

        auto globalVisibility = op.getGlobalVisibility().getValue();
        auto pglobalVisibility =
            EnumSerializer::serializeVisibilityKind(globalVisibility);
        pGlobalOp.set_global_visibility(pglobalVisibility);

        auto symVisibilityOptional = op.getSymVisibility();
        if (symVisibilityOptional) {
          auto symVisibility = symVisibilityOptional.value();
          *pGlobalOp.mutable_sym_visibility() = symVisibility;
        }

        auto symType = op.getSymType();
        auto symTypeID = internType(typeCache, symType);

        protocir::CIRTypeID psymTypeID;
        psymTypeID.set_id(symTypeID);

        *pGlobalOp.mutable_sym_type() = psymTypeID;

        auto linkage = op.getLinkage();
        auto plinkage = EnumSerializer::serializeGlobalLinkageKind(linkage);
        pGlobalOp.set_linkage(plinkage);

        auto tlsModelOptional = op.getTlsModel();
        if (tlsModelOptional) {
          auto tlsModel = tlsModelOptional.value();
          auto ptlsModel = EnumSerializer::serializeTLS_Model(tlsModel);
          pGlobalOp.set_tls_model(ptlsModel);
        }

        auto initialValueOptional = op.getInitialValue();
        if (initialValueOptional) {
          auto initialValue = initialValueOptional.value();

          std::string initialValueStr;
          llvm::raw_string_ostream initialValueRawStream(initialValueStr);
          initialValue.print(initialValueRawStream);
          *pGlobalOp.mutable_initial_value() = initialValueStr;
        }

        auto comdat = op.getComdat();
        pGlobalOp.set_comdat(comdat);

        auto constant = op.getConstant();
        pGlobalOp.set_constant(constant);

        auto dsolocal = op.getDsolocal();
        pGlobalOp.set_dsolocal(dsolocal);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pGlobalOp.set_alignment(alignment);
        }

        auto sectionOptional = op.getSection();
        if (sectionOptional) {
          auto section = sectionOptional.value();
          *pGlobalOp.mutable_section() = section;
        }

        pInst.mutable_global_op()->CopyFrom(pGlobalOp);
      })

      .Case<cir::GotoOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::GotoOp op) {
        protocir::CIRGotoOp pGotoOp;
        pInst.mutable_base()->set_id(instID);

        auto label = op.getLabel();
        *pGotoOp.mutable_label() = label;

        pInst.mutable_goto_op()->CopyFrom(pGotoOp);
      })

      .Case<cir::IfOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                        &opCache](cir::IfOp op) {
        protocir::CIRIfOp pIfOp;
        pInst.mutable_base()->set_id(instID);

        auto condition = op.getCondition();
        auto conditionValue = Serializer::serializeValue(
            condition, pModuleID, typeCache, opCache, blockCache);
        *pIfOp.mutable_condition() = conditionValue;

        pInst.mutable_if_op()->CopyFrom(pIfOp);
      })

      .Case<cir::IsConstantOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::IsConstantOp op) {
        protocir::CIRIsConstantOp pIsConstantOp;
        pInst.mutable_base()->set_id(instID);

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pIsConstantOp.mutable_val() = valValue;

        pInst.mutable_is_constant_op()->CopyFrom(pIsConstantOp);
      })

      .Case<cir::IsFPClassOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::IsFPClassOp op) {
        protocir::CIRIsFPClassOp pIsFPClassOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pIsFPClassOp.mutable_src() = srcValue;

        auto flags = op.getFlags();
        pIsFPClassOp.set_flags(flags);

        pInst.mutable_is_fp_class_op()->CopyFrom(pIsFPClassOp);
      })

      .Case<cir::IterBeginOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::IterBeginOp op) {
        protocir::CIRIterBeginOp pIterBeginOp;
        pInst.mutable_base()->set_id(instID);

        auto container = op.getContainer();
        auto containerValue = Serializer::serializeValue(
            container, pModuleID, typeCache, opCache, blockCache);
        *pIterBeginOp.mutable_container() = containerValue;

        auto originalFn = op.getOriginalFn();
        *pIterBeginOp.mutable_original_fn() = originalFn;

        pInst.mutable_iter_begin_op()->CopyFrom(pIterBeginOp);
      })

      .Case<cir::IterEndOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::IterEndOp op) {
        protocir::CIRIterEndOp pIterEndOp;
        pInst.mutable_base()->set_id(instID);

        auto container = op.getContainer();
        auto containerValue = Serializer::serializeValue(
            container, pModuleID, typeCache, opCache, blockCache);
        *pIterEndOp.mutable_container() = containerValue;

        auto originalFn = op.getOriginalFn();
        *pIterEndOp.mutable_original_fn() = originalFn;

        pInst.mutable_iter_end_op()->CopyFrom(pIterEndOp);
      })

      .Case<cir::LLVMIntrinsicCallOp>([instID, &pInst, pModuleID, &typeCache,
                                       &blockCache,
                                       &opCache](cir::LLVMIntrinsicCallOp op) {
        protocir::CIRLLVMIntrinsicCallOp pLLVMIntrinsicCallOp;
        pInst.mutable_base()->set_id(instID);

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pLLVMIntrinsicCallOp.add_arg_ops();
          auto eargOpsValue = Serializer::serializeValue(
              eargOps, pModuleID, typeCache, opCache, blockCache);
          eargOpsProto->CopyFrom(eargOpsValue);
        }

        auto intrinsicName = op.getIntrinsicName();
        *pLLVMIntrinsicCallOp.mutable_intrinsic_name() = intrinsicName;

        pInst.mutable_llvm_intrinsic_call_op()->CopyFrom(pLLVMIntrinsicCallOp);
      })

      .Case<cir::LLrintOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::LLrintOp op) {
        protocir::CIRLLrintOp pLLrintOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLLrintOp.mutable_src() = srcValue;

        pInst.mutable_l_lrint_op()->CopyFrom(pLLrintOp);
      })

      .Case<cir::LLroundOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::LLroundOp op) {
        protocir::CIRLLroundOp pLLroundOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLLroundOp.mutable_src() = srcValue;

        pInst.mutable_l_lround_op()->CopyFrom(pLLroundOp);
      })

      .Case<cir::LabelOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::LabelOp op) {
        protocir::CIRLabelOp pLabelOp;
        pInst.mutable_base()->set_id(instID);

        auto label = op.getLabel();
        *pLabelOp.mutable_label() = label;

        pInst.mutable_label_op()->CopyFrom(pLabelOp);
      })

      .Case<cir::LoadOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::LoadOp op) {
        protocir::CIRLoadOp pLoadOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pLoadOp.mutable_addr() = addrValue;

        auto isDeref = op.getIsDeref();
        pLoadOp.set_is_deref(isDeref);

        auto isVolatile = op.getIsVolatile();
        pLoadOp.set_is_volatile(isVolatile);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pLoadOp.set_alignment(alignment);
        }

        auto memOrderOptional = op.getMemOrder();
        if (memOrderOptional) {
          auto memOrder = memOrderOptional.value();
          auto pmemOrder = EnumSerializer::serializeMemOrder(memOrder);
          pLoadOp.set_mem_order(pmemOrder);
        }

        pInst.mutable_load_op()->CopyFrom(pLoadOp);
      })

      .Case<cir::Log10Op>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::Log10Op op) {
        protocir::CIRLog10Op pLog10Op;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLog10Op.mutable_src() = srcValue;

        pInst.mutable_log10_op()->CopyFrom(pLog10Op);
      })

      .Case<cir::Log2Op>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::Log2Op op) {
        protocir::CIRLog2Op pLog2Op;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLog2Op.mutable_src() = srcValue;

        pInst.mutable_log2_op()->CopyFrom(pLog2Op);
      })

      .Case<cir::LogOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::LogOp op) {
        protocir::CIRLogOp pLogOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLogOp.mutable_src() = srcValue;

        pInst.mutable_log_op()->CopyFrom(pLogOp);
      })

      .Case<cir::LrintOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::LrintOp op) {
        protocir::CIRLrintOp pLrintOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLrintOp.mutable_src() = srcValue;

        pInst.mutable_lrint_op()->CopyFrom(pLrintOp);
      })

      .Case<cir::LroundOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::LroundOp op) {
        protocir::CIRLroundOp pLroundOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pLroundOp.mutable_src() = srcValue;

        pInst.mutable_lround_op()->CopyFrom(pLroundOp);
      })

      .Case<cir::MemChrOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemChrOp op) {
        protocir::CIRMemChrOp pMemChrOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemChrOp.mutable_src() = srcValue;

        auto pattern = op.getPattern();
        auto patternValue = Serializer::serializeValue(
            pattern, pModuleID, typeCache, opCache, blockCache);
        *pMemChrOp.mutable_pattern() = patternValue;

        auto len = op.getLen();
        auto lenValue = Serializer::serializeValue(len, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemChrOp.mutable_len() = lenValue;

        pInst.mutable_mem_chr_op()->CopyFrom(pMemChrOp);
      })

      .Case<cir::MemCpyInlineOp>([instID, &pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::MemCpyInlineOp op) {
        protocir::CIRMemCpyInlineOp pMemCpyInlineOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemCpyInlineOp.mutable_dst() = dstValue;

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemCpyInlineOp.mutable_src() = srcValue;

        auto len = op.getLen();
        pMemCpyInlineOp.set_len(len);

        pInst.mutable_mem_cpy_inline_op()->CopyFrom(pMemCpyInlineOp);
      })

      .Case<cir::MemCpyOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemCpyOp op) {
        protocir::CIRMemCpyOp pMemCpyOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemCpyOp.mutable_dst() = dstValue;

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemCpyOp.mutable_src() = srcValue;

        auto len = op.getLen();
        auto lenValue = Serializer::serializeValue(len, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemCpyOp.mutable_len() = lenValue;

        pInst.mutable_mem_cpy_op()->CopyFrom(pMemCpyOp);
      })

      .Case<cir::MemMoveOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::MemMoveOp op) {
        protocir::CIRMemMoveOp pMemMoveOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemMoveOp.mutable_dst() = dstValue;

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemMoveOp.mutable_src() = srcValue;

        auto len = op.getLen();
        auto lenValue = Serializer::serializeValue(len, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemMoveOp.mutable_len() = lenValue;

        pInst.mutable_mem_move_op()->CopyFrom(pMemMoveOp);
      })

      .Case<cir::MemSetInlineOp>([instID, &pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::MemSetInlineOp op) {
        protocir::CIRMemSetInlineOp pMemSetInlineOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemSetInlineOp.mutable_dst() = dstValue;

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemSetInlineOp.mutable_val() = valValue;

        auto len = op.getLen();
        pMemSetInlineOp.set_len(len);

        pInst.mutable_mem_set_inline_op()->CopyFrom(pMemSetInlineOp);
      })

      .Case<cir::MemSetOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemSetOp op) {
        protocir::CIRMemSetOp pMemSetOp;
        pInst.mutable_base()->set_id(instID);

        auto dst = op.getDst();
        auto dstValue = Serializer::serializeValue(dst, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemSetOp.mutable_dst() = dstValue;

        auto val = op.getVal();
        auto valValue = Serializer::serializeValue(val, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemSetOp.mutable_val() = valValue;

        auto len = op.getLen();
        auto lenValue = Serializer::serializeValue(len, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pMemSetOp.mutable_len() = lenValue;

        pInst.mutable_mem_set_op()->CopyFrom(pMemSetOp);
      })

      .Case<cir::NearbyintOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::NearbyintOp op) {
        protocir::CIRNearbyintOp pNearbyintOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pNearbyintOp.mutable_src() = srcValue;

        pInst.mutable_nearbyint_op()->CopyFrom(pNearbyintOp);
      })

      .Case<cir::ObjSizeOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ObjSizeOp op) {
        protocir::CIRObjSizeOp pObjSizeOp;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pObjSizeOp.mutable_ptr() = ptrValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeSizeInfoType(kind);
        pObjSizeOp.set_kind(pkind);

        auto dynamic = op.getDynamic();
        pObjSizeOp.set_dynamic(dynamic);

        pInst.mutable_obj_size_op()->CopyFrom(pObjSizeOp);
      })

      .Case<cir::PowOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::PowOp op) {
        protocir::CIRPowOp pPowOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pPowOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pPowOp.mutable_rhs() = rhsValue;

        pInst.mutable_pow_op()->CopyFrom(pPowOp);
      })

      .Case<cir::PrefetchOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::PrefetchOp op) {
        protocir::CIRPrefetchOp pPrefetchOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pPrefetchOp.mutable_addr() = addrValue;

        auto locality = op.getLocality();
        pPrefetchOp.set_locality(locality);

        auto isWrite = op.getIsWrite();
        pPrefetchOp.set_is_write(isWrite);

        pInst.mutable_prefetch_op()->CopyFrom(pPrefetchOp);
      })

      .Case<cir::PtrDiffOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::PtrDiffOp op) {
        protocir::CIRPtrDiffOp pPtrDiffOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pPtrDiffOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pPtrDiffOp.mutable_rhs() = rhsValue;

        pInst.mutable_ptr_diff_op()->CopyFrom(pPtrDiffOp);
      })

      .Case<cir::PtrMaskOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::PtrMaskOp op) {
        protocir::CIRPtrMaskOp pPtrMaskOp;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pPtrMaskOp.mutable_ptr() = ptrValue;

        auto mask = op.getMask();
        auto maskValue = Serializer::serializeValue(mask, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pPtrMaskOp.mutable_mask() = maskValue;

        pInst.mutable_ptr_mask_op()->CopyFrom(pPtrMaskOp);
      })

      .Case<cir::PtrStrideOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::PtrStrideOp op) {
        protocir::CIRPtrStrideOp pPtrStrideOp;
        pInst.mutable_base()->set_id(instID);

        auto base = op.getBase();
        auto baseValue = Serializer::serializeValue(base, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pPtrStrideOp.mutable_base() = baseValue;

        auto stride = op.getStride();
        auto strideValue = Serializer::serializeValue(
            stride, pModuleID, typeCache, opCache, blockCache);
        *pPtrStrideOp.mutable_stride() = strideValue;

        pInst.mutable_ptr_stride_op()->CopyFrom(pPtrStrideOp);
      })

      .Case<cir::ResumeOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ResumeOp op) {
        protocir::CIRResumeOp pResumeOp;
        pInst.mutable_base()->set_id(instID);

        auto exceptionPtrRaw = op.getExceptionPtr();
        if (exceptionPtrRaw) {
          auto exceptionPtrValue = Serializer::serializeValue(
              exceptionPtrRaw, pModuleID, typeCache, opCache, blockCache);
          *pResumeOp.mutable_exception_ptr() = exceptionPtrValue;
        }

        auto typeIdRaw = op.getTypeId();
        if (typeIdRaw) {
          auto typeIdValue = Serializer::serializeValue(
              typeIdRaw, pModuleID, typeCache, opCache, blockCache);
          *pResumeOp.mutable_type_id() = typeIdValue;
        }

        auto rethrow = op.getRethrow();
        pResumeOp.set_rethrow(rethrow);

        pInst.mutable_resume_op()->CopyFrom(pResumeOp);
      })

      .Case<cir::ReturnAddrOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ReturnAddrOp op) {
        protocir::CIRReturnAddrOp pReturnAddrOp;
        pInst.mutable_base()->set_id(instID);

        auto level = op.getLevel();
        auto levelValue = Serializer::serializeValue(
            level, pModuleID, typeCache, opCache, blockCache);
        *pReturnAddrOp.mutable_level() = levelValue;

        pInst.mutable_return_addr_op()->CopyFrom(pReturnAddrOp);
      })

      .Case<cir::ReturnOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ReturnOp op) {
        protocir::CIRReturnOp pReturnOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        for (auto einput : input) {
          auto einputProto = pReturnOp.add_input();
          auto einputValue = Serializer::serializeValue(
              einput, pModuleID, typeCache, opCache, blockCache);
          einputProto->CopyFrom(einputValue);
        }

        pInst.mutable_return_op()->CopyFrom(pReturnOp);
      })

      .Case<cir::RintOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::RintOp op) {
        protocir::CIRRintOp pRintOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pRintOp.mutable_src() = srcValue;

        pInst.mutable_rint_op()->CopyFrom(pRintOp);
      })

      .Case<cir::RotateOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::RotateOp op) {
        protocir::CIRRotateOp pRotateOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pRotateOp.mutable_src() = srcValue;

        auto amt = op.getAmt();
        auto amtValue = Serializer::serializeValue(amt, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pRotateOp.mutable_amt() = amtValue;

        auto left = op.getLeft();
        pRotateOp.set_left(left);

        pInst.mutable_rotate_op()->CopyFrom(pRotateOp);
      })

      .Case<cir::RoundOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::RoundOp op) {
        protocir::CIRRoundOp pRoundOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pRoundOp.mutable_src() = srcValue;

        pInst.mutable_round_op()->CopyFrom(pRoundOp);
      })

      .Case<cir::ScopeOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ScopeOp op) {
        protocir::CIRScopeOp pScopeOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_scope_op()->CopyFrom(pScopeOp);
      })

      .Case<cir::SelectOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::SelectOp op) {
        protocir::CIRSelectOp pSelectOp;
        pInst.mutable_base()->set_id(instID);

        auto condition = op.getCondition();
        auto conditionValue = Serializer::serializeValue(
            condition, pModuleID, typeCache, opCache, blockCache);
        *pSelectOp.mutable_condition() = conditionValue;

        auto trueValue = op.getTrueValue();
        auto trueValueValue = Serializer::serializeValue(
            trueValue, pModuleID, typeCache, opCache, blockCache);
        *pSelectOp.mutable_true_value() = trueValueValue;

        auto falseValue = op.getFalseValue();
        auto falseValueValue = Serializer::serializeValue(
            falseValue, pModuleID, typeCache, opCache, blockCache);
        *pSelectOp.mutable_false_value() = falseValueValue;

        pInst.mutable_select_op()->CopyFrom(pSelectOp);
      })

      .Case<cir::SetBitfieldOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::SetBitfieldOp op) {
        protocir::CIRSetBitfieldOp pSetBitfieldOp;
        pInst.mutable_base()->set_id(instID);

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pSetBitfieldOp.mutable_addr() = addrValue;

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pSetBitfieldOp.mutable_src() = srcValue;

        auto isVolatile = op.getIsVolatile();
        pSetBitfieldOp.set_is_volatile(isVolatile);

        pInst.mutable_set_bitfield_op()->CopyFrom(pSetBitfieldOp);
      })

      .Case<cir::ShiftOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ShiftOp op) {
        protocir::CIRShiftOp pShiftOp;
        pInst.mutable_base()->set_id(instID);

        auto value = op.getValue();
        auto valueValue = Serializer::serializeValue(
            value, pModuleID, typeCache, opCache, blockCache);
        *pShiftOp.mutable_value() = valueValue;

        auto amount = op.getAmount();
        auto amountValue = Serializer::serializeValue(
            amount, pModuleID, typeCache, opCache, blockCache);
        *pShiftOp.mutable_amount() = amountValue;

        auto isShiftleft = op.getIsShiftleft();
        pShiftOp.set_is_shiftleft(isShiftleft);

        pInst.mutable_shift_op()->CopyFrom(pShiftOp);
      })

      .Case<cir::SignBitOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::SignBitOp op) {
        protocir::CIRSignBitOp pSignBitOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pSignBitOp.mutable_input() = inputValue;

        pInst.mutable_sign_bit_op()->CopyFrom(pSignBitOp);
      })

      .Case<cir::SinOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::SinOp op) {
        protocir::CIRSinOp pSinOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pSinOp.mutable_src() = srcValue;

        pInst.mutable_sin_op()->CopyFrom(pSinOp);
      })

      .Case<cir::SqrtOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::SqrtOp op) {
        protocir::CIRSqrtOp pSqrtOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pSqrtOp.mutable_src() = srcValue;

        pInst.mutable_sqrt_op()->CopyFrom(pSqrtOp);
      })

      .Case<cir::StackRestoreOp>([instID, &pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::StackRestoreOp op) {
        protocir::CIRStackRestoreOp pStackRestoreOp;
        pInst.mutable_base()->set_id(instID);

        auto ptr = op.getPtr();
        auto ptrValue = Serializer::serializeValue(ptr, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pStackRestoreOp.mutable_ptr() = ptrValue;

        pInst.mutable_stack_restore_op()->CopyFrom(pStackRestoreOp);
      })

      .Case<cir::StackSaveOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::StackSaveOp op) {
        protocir::CIRStackSaveOp pStackSaveOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_stack_save_op()->CopyFrom(pStackSaveOp);
      })

      .Case<cir::StdFindOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::StdFindOp op) {
        protocir::CIRStdFindOp pStdFindOp;
        pInst.mutable_base()->set_id(instID);

        auto first = op.getFirst();
        auto firstValue = Serializer::serializeValue(
            first, pModuleID, typeCache, opCache, blockCache);
        *pStdFindOp.mutable_first() = firstValue;

        auto last = op.getLast();
        auto lastValue = Serializer::serializeValue(last, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pStdFindOp.mutable_last() = lastValue;

        auto pattern = op.getPattern();
        auto patternValue = Serializer::serializeValue(
            pattern, pModuleID, typeCache, opCache, blockCache);
        *pStdFindOp.mutable_pattern() = patternValue;

        auto originalFn = op.getOriginalFn();
        *pStdFindOp.mutable_original_fn() = originalFn;

        pInst.mutable_std_find_op()->CopyFrom(pStdFindOp);
      })

      .Case<cir::StoreOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::StoreOp op) {
        protocir::CIRStoreOp pStoreOp;
        pInst.mutable_base()->set_id(instID);

        auto value = op.getValue();
        auto valueValue = Serializer::serializeValue(
            value, pModuleID, typeCache, opCache, blockCache);
        *pStoreOp.mutable_value() = valueValue;

        auto addr = op.getAddr();
        auto addrValue = Serializer::serializeValue(addr, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pStoreOp.mutable_addr() = addrValue;

        auto isVolatile = op.getIsVolatile();
        pStoreOp.set_is_volatile(isVolatile);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pStoreOp.set_alignment(alignment);
        }

        auto memOrderOptional = op.getMemOrder();
        if (memOrderOptional) {
          auto memOrder = memOrderOptional.value();
          auto pmemOrder = EnumSerializer::serializeMemOrder(memOrder);
          pStoreOp.set_mem_order(pmemOrder);
        }

        pInst.mutable_store_op()->CopyFrom(pStoreOp);
      })

      .Case<cir::SwitchFlatOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::SwitchFlatOp op) {
        protocir::CIRSwitchFlatOp pSwitchFlatOp;
        pInst.mutable_base()->set_id(instID);

        auto condition = op.getCondition();
        auto conditionValue = Serializer::serializeValue(
            condition, pModuleID, typeCache, opCache, blockCache);
        *pSwitchFlatOp.mutable_condition() = conditionValue;

        auto defaultOperands = op.getDefaultOperands();
        for (auto edefaultOperands : defaultOperands) {
          auto edefaultOperandsProto = pSwitchFlatOp.add_default_operands();
          auto edefaultOperandsValue = Serializer::serializeValue(
              edefaultOperands, pModuleID, typeCache, opCache, blockCache);
          edefaultOperandsProto->CopyFrom(edefaultOperandsValue);
        }

        auto caseOperands = op.getCaseOperands();
        for (auto ecaseOperands : caseOperands) {
          auto ecaseOperandsProto = pSwitchFlatOp.add_case_operands();
          for (auto eecaseOperands : ecaseOperands) {
            auto eecaseOperandsProto = ecaseOperandsProto->add_range();
            auto eecaseOperandsValue = Serializer::serializeValue(
                eecaseOperands, pModuleID, typeCache, opCache, blockCache);
            eecaseOperandsProto->CopyFrom(eecaseOperandsValue);
          }
        }

        auto caseOperandSegments = op.getCaseOperandSegments();
        for (auto ecaseOperandSegments : caseOperandSegments) {
          pSwitchFlatOp.add_case_operand_segments(ecaseOperandSegments);
        }

        auto defaultDestination = op.getDefaultDestination();
        auto defaultDestinationID = internBlock(blockCache, defaultDestination);
        protocir::CIRBlockID pdefaultDestinationID;
        pdefaultDestinationID.set_id(defaultDestinationID);

        *pSwitchFlatOp.mutable_default_destination() = pdefaultDestinationID;

        auto caseDestinations = op.getCaseDestinations();
        for (auto ecaseDestinations : caseDestinations) {
          auto ecaseDestinationsProto = pSwitchFlatOp.add_case_destinations();
          auto ecaseDestinationsID = internBlock(blockCache, ecaseDestinations);
          protocir::CIRBlockID pecaseDestinationsID;
          pecaseDestinationsID.set_id(ecaseDestinationsID);
        }

        pInst.mutable_switch_flat_op()->CopyFrom(pSwitchFlatOp);
      })

      .Case<cir::SwitchOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::SwitchOp op) {
        protocir::CIRSwitchOp pSwitchOp;
        pInst.mutable_base()->set_id(instID);

        auto condition = op.getCondition();
        auto conditionValue = Serializer::serializeValue(
            condition, pModuleID, typeCache, opCache, blockCache);
        *pSwitchOp.mutable_condition() = conditionValue;

        pInst.mutable_switch_op()->CopyFrom(pSwitchOp);
      })

      .Case<cir::TernaryOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::TernaryOp op) {
        protocir::CIRTernaryOp pTernaryOp;
        pInst.mutable_base()->set_id(instID);

        auto cond = op.getCond();
        auto condValue = Serializer::serializeValue(cond, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pTernaryOp.mutable_cond() = condValue;

        pInst.mutable_ternary_op()->CopyFrom(pTernaryOp);
      })

      .Case<cir::ThrowOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ThrowOp op) {
        protocir::CIRThrowOp pThrowOp;
        pInst.mutable_base()->set_id(instID);

        auto exceptionPtrRaw = op.getExceptionPtr();
        if (exceptionPtrRaw) {
          auto exceptionPtrValue = Serializer::serializeValue(
              exceptionPtrRaw, pModuleID, typeCache, opCache, blockCache);
          *pThrowOp.mutable_exception_ptr() = exceptionPtrValue;
        }

        auto typeInfoOptional = op.getTypeInfo();
        if (typeInfoOptional) {
          auto typeInfo = typeInfoOptional.value();
          *pThrowOp.mutable_type_info() = typeInfo;
        }

        auto dtorOptional = op.getDtor();
        if (dtorOptional) {
          auto dtor = dtorOptional.value();
          *pThrowOp.mutable_dtor() = dtor;
        }

        pInst.mutable_throw_op()->CopyFrom(pThrowOp);
      })

      .Case<cir::TrapOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::TrapOp op) {
        protocir::CIRTrapOp pTrapOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_trap_op()->CopyFrom(pTrapOp);
      })

      .Case<cir::TruncOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::TruncOp op) {
        protocir::CIRTruncOp pTruncOp;
        pInst.mutable_base()->set_id(instID);

        auto src = op.getSrc();
        auto srcValue = Serializer::serializeValue(src, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pTruncOp.mutable_src() = srcValue;

        pInst.mutable_trunc_op()->CopyFrom(pTruncOp);
      })

      .Case<cir::TryCallOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::TryCallOp op) {
        protocir::CIRTryCallOp pTryCallOp;
        pInst.mutable_base()->set_id(instID);

        auto contOperands = op.getContOperands();
        for (auto econtOperands : contOperands) {
          auto econtOperandsProto = pTryCallOp.add_cont_operands();
          auto econtOperandsValue = Serializer::serializeValue(
              econtOperands, pModuleID, typeCache, opCache, blockCache);
          econtOperandsProto->CopyFrom(econtOperandsValue);
        }

        auto landingPadOperands = op.getLandingPadOperands();
        for (auto elandingPadOperands : landingPadOperands) {
          auto elandingPadOperandsProto = pTryCallOp.add_landing_pad_operands();
          auto elandingPadOperandsValue = Serializer::serializeValue(
              elandingPadOperands, pModuleID, typeCache, opCache, blockCache);
          elandingPadOperandsProto->CopyFrom(elandingPadOperandsValue);
        }

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pTryCallOp.add_arg_ops();
          auto eargOpsValue = Serializer::serializeValue(
              eargOps, pModuleID, typeCache, opCache, blockCache);
          eargOpsProto->CopyFrom(eargOpsValue);
        }

        auto calleeOptional = op.getCallee();
        if (calleeOptional) {
          auto callee = calleeOptional.value();
          *pTryCallOp.mutable_callee() = callee;
        }

        auto callingConv = op.getCallingConv();
        auto pcallingConv = EnumSerializer::serializeCallingConv(callingConv);
        pTryCallOp.set_calling_conv(pcallingConv);

        auto cont = op.getCont();
        auto contID = internBlock(blockCache, cont);
        protocir::CIRBlockID pcontID;
        pcontID.set_id(contID);

        *pTryCallOp.mutable_cont() = pcontID;

        auto landingPad = op.getLandingPad();
        auto landingPadID = internBlock(blockCache, landingPad);
        protocir::CIRBlockID plandingPadID;
        plandingPadID.set_id(landingPadID);

        *pTryCallOp.mutable_landing_pad() = plandingPadID;

        pInst.mutable_try_call_op()->CopyFrom(pTryCallOp);
      })

      .Case<cir::TryOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::TryOp op) {
        protocir::CIRTryOp pTryOp;
        pInst.mutable_base()->set_id(instID);

        auto synthetic = op.getSynthetic();
        pTryOp.set_synthetic(synthetic);

        auto cleanup = op.getCleanup();
        pTryOp.set_cleanup(cleanup);

        pInst.mutable_try_op()->CopyFrom(pTryOp);
      })

      .Case<cir::UnaryOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::UnaryOp op) {
        protocir::CIRUnaryOp pUnaryOp;
        pInst.mutable_base()->set_id(instID);

        auto input = op.getInput();
        auto inputValue = Serializer::serializeValue(
            input, pModuleID, typeCache, opCache, blockCache);
        *pUnaryOp.mutable_input() = inputValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeUnaryOpKind(kind);
        pUnaryOp.set_kind(pkind);

        pInst.mutable_unary_op()->CopyFrom(pUnaryOp);
      })

      .Case<cir::UnreachableOp>([instID, &pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::UnreachableOp op) {
        protocir::CIRUnreachableOp pUnreachableOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_unreachable_op()->CopyFrom(pUnreachableOp);
      })

      .Case<cir::VAArgOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::VAArgOp op) {
        protocir::CIRVAArgOp pVAArgOp;
        pInst.mutable_base()->set_id(instID);

        auto argList = op.getArgList();
        auto argListValue = Serializer::serializeValue(
            argList, pModuleID, typeCache, opCache, blockCache);
        *pVAArgOp.mutable_arg_list() = argListValue;

        pInst.mutable_va_arg_op()->CopyFrom(pVAArgOp);
      })

      .Case<cir::VACopyOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::VACopyOp op) {
        protocir::CIRVACopyOp pVACopyOp;
        pInst.mutable_base()->set_id(instID);

        auto dstList = op.getDstList();
        auto dstListValue = Serializer::serializeValue(
            dstList, pModuleID, typeCache, opCache, blockCache);
        *pVACopyOp.mutable_dst_list() = dstListValue;

        auto srcList = op.getSrcList();
        auto srcListValue = Serializer::serializeValue(
            srcList, pModuleID, typeCache, opCache, blockCache);
        *pVACopyOp.mutable_src_list() = srcListValue;

        pInst.mutable_va_copy_op()->CopyFrom(pVACopyOp);
      })

      .Case<cir::VAEndOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::VAEndOp op) {
        protocir::CIRVAEndOp pVAEndOp;
        pInst.mutable_base()->set_id(instID);

        auto argList = op.getArgList();
        auto argListValue = Serializer::serializeValue(
            argList, pModuleID, typeCache, opCache, blockCache);
        *pVAEndOp.mutable_arg_list() = argListValue;

        pInst.mutable_va_end_op()->CopyFrom(pVAEndOp);
      })

      .Case<cir::VAStartOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::VAStartOp op) {
        protocir::CIRVAStartOp pVAStartOp;
        pInst.mutable_base()->set_id(instID);

        auto argList = op.getArgList();
        auto argListValue = Serializer::serializeValue(
            argList, pModuleID, typeCache, opCache, blockCache);
        *pVAStartOp.mutable_arg_list() = argListValue;

        pInst.mutable_va_start_op()->CopyFrom(pVAStartOp);
      })

      .Case<cir::VTTAddrPointOp>([instID, &pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::VTTAddrPointOp op) {
        protocir::CIRVTTAddrPointOp pVTTAddrPointOp;
        pInst.mutable_base()->set_id(instID);

        auto symAddrRaw = op.getSymAddr();
        if (symAddrRaw) {
          auto symAddrValue = Serializer::serializeValue(
              symAddrRaw, pModuleID, typeCache, opCache, blockCache);
          *pVTTAddrPointOp.mutable_sym_addr() = symAddrValue;
        }

        auto nameOptional = op.getName();
        if (nameOptional) {
          auto name = nameOptional.value();
          *pVTTAddrPointOp.mutable_name() = name;
        }

        auto offset = op.getOffset();
        pVTTAddrPointOp.set_offset(offset);

        pInst.mutable_vtt_addr_point_op()->CopyFrom(pVTTAddrPointOp);
      })

      .Case<cir::VTableAddrPointOp>([instID, &pInst, pModuleID, &typeCache,
                                     &blockCache,
                                     &opCache](cir::VTableAddrPointOp op) {
        protocir::CIRVTableAddrPointOp pVTableAddrPointOp;
        pInst.mutable_base()->set_id(instID);

        auto symAddrRaw = op.getSymAddr();
        if (symAddrRaw) {
          auto symAddrValue = Serializer::serializeValue(
              symAddrRaw, pModuleID, typeCache, opCache, blockCache);
          *pVTableAddrPointOp.mutable_sym_addr() = symAddrValue;
        }

        auto nameOptional = op.getName();
        if (nameOptional) {
          auto name = nameOptional.value();
          *pVTableAddrPointOp.mutable_name() = name;
        }

        auto vtableIndex = op.getVtableIndex();
        pVTableAddrPointOp.set_vtable_index(vtableIndex);

        auto addressPointIndex = op.getAddressPointIndex();
        pVTableAddrPointOp.set_address_point_index(addressPointIndex);

        pInst.mutable_v_table_addr_point_op()->CopyFrom(pVTableAddrPointOp);
      })

      .Case<cir::VecCmpOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::VecCmpOp op) {
        protocir::CIRVecCmpOp pVecCmpOp;
        pInst.mutable_base()->set_id(instID);

        auto lhs = op.getLhs();
        auto lhsValue = Serializer::serializeValue(lhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pVecCmpOp.mutable_lhs() = lhsValue;

        auto rhs = op.getRhs();
        auto rhsValue = Serializer::serializeValue(rhs, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pVecCmpOp.mutable_rhs() = rhsValue;

        auto kind = op.getKind();
        auto pkind = EnumSerializer::serializeCmpOpKind(kind);
        pVecCmpOp.set_kind(pkind);

        pInst.mutable_vec_cmp_op()->CopyFrom(pVecCmpOp);
      })

      .Case<cir::VecCreateOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::VecCreateOp op) {
        protocir::CIRVecCreateOp pVecCreateOp;
        pInst.mutable_base()->set_id(instID);

        auto elements = op.getElements();
        for (auto eelements : elements) {
          auto eelementsProto = pVecCreateOp.add_elements();
          auto eelementsValue = Serializer::serializeValue(
              eelements, pModuleID, typeCache, opCache, blockCache);
          eelementsProto->CopyFrom(eelementsValue);
        }

        pInst.mutable_vec_create_op()->CopyFrom(pVecCreateOp);
      })

      .Case<cir::VecExtractOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecExtractOp op) {
        protocir::CIRVecExtractOp pVecExtractOp;
        pInst.mutable_base()->set_id(instID);

        auto vec = op.getVec();
        auto vecValue = Serializer::serializeValue(vec, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pVecExtractOp.mutable_vec() = vecValue;

        auto index = op.getIndex();
        auto indexValue = Serializer::serializeValue(
            index, pModuleID, typeCache, opCache, blockCache);
        *pVecExtractOp.mutable_index() = indexValue;

        pInst.mutable_vec_extract_op()->CopyFrom(pVecExtractOp);
      })

      .Case<cir::VecInsertOp>([instID, &pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::VecInsertOp op) {
        protocir::CIRVecInsertOp pVecInsertOp;
        pInst.mutable_base()->set_id(instID);

        auto vec = op.getVec();
        auto vecValue = Serializer::serializeValue(vec, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pVecInsertOp.mutable_vec() = vecValue;

        auto value = op.getValue();
        auto valueValue = Serializer::serializeValue(
            value, pModuleID, typeCache, opCache, blockCache);
        *pVecInsertOp.mutable_value() = valueValue;

        auto index = op.getIndex();
        auto indexValue = Serializer::serializeValue(
            index, pModuleID, typeCache, opCache, blockCache);
        *pVecInsertOp.mutable_index() = indexValue;

        pInst.mutable_vec_insert_op()->CopyFrom(pVecInsertOp);
      })

      .Case<cir::VecShuffleDynamicOp>([instID, &pInst, pModuleID, &typeCache,
                                       &blockCache,
                                       &opCache](cir::VecShuffleDynamicOp op) {
        protocir::CIRVecShuffleDynamicOp pVecShuffleDynamicOp;
        pInst.mutable_base()->set_id(instID);

        auto vec = op.getVec();
        auto vecValue = Serializer::serializeValue(vec, pModuleID, typeCache,
                                                   opCache, blockCache);
        *pVecShuffleDynamicOp.mutable_vec() = vecValue;

        auto indices = op.getIndices();
        auto indicesValue = Serializer::serializeValue(
            indices, pModuleID, typeCache, opCache, blockCache);
        *pVecShuffleDynamicOp.mutable_indices() = indicesValue;

        pInst.mutable_vec_shuffle_dynamic_op()->CopyFrom(pVecShuffleDynamicOp);
      })

      .Case<cir::VecShuffleOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecShuffleOp op) {
        protocir::CIRVecShuffleOp pVecShuffleOp;
        pInst.mutable_base()->set_id(instID);

        auto vec1 = op.getVec1();
        auto vec1Value = Serializer::serializeValue(vec1, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pVecShuffleOp.mutable_vec1() = vec1Value;

        auto vec2 = op.getVec2();
        auto vec2Value = Serializer::serializeValue(vec2, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pVecShuffleOp.mutable_vec2() = vec2Value;

        pInst.mutable_vec_shuffle_op()->CopyFrom(pVecShuffleOp);
      })

      .Case<cir::VecSplatOp>([instID, &pInst, pModuleID, &typeCache,
                              &blockCache, &opCache](cir::VecSplatOp op) {
        protocir::CIRVecSplatOp pVecSplatOp;
        pInst.mutable_base()->set_id(instID);

        auto value = op.getValue();
        auto valueValue = Serializer::serializeValue(
            value, pModuleID, typeCache, opCache, blockCache);
        *pVecSplatOp.mutable_value() = valueValue;

        pInst.mutable_vec_splat_op()->CopyFrom(pVecSplatOp);
      })

      .Case<cir::VecTernaryOp>([instID, &pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecTernaryOp op) {
        protocir::CIRVecTernaryOp pVecTernaryOp;
        pInst.mutable_base()->set_id(instID);

        auto cond = op.getCond();
        auto condValue = Serializer::serializeValue(cond, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pVecTernaryOp.mutable_cond() = condValue;

        auto vec1 = op.getVec1();
        auto vec1Value = Serializer::serializeValue(vec1, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pVecTernaryOp.mutable_vec1() = vec1Value;

        auto vec2 = op.getVec2();
        auto vec2Value = Serializer::serializeValue(vec2, pModuleID, typeCache,
                                                    opCache, blockCache);
        *pVecTernaryOp.mutable_vec2() = vec2Value;

        pInst.mutable_vec_ternary_op()->CopyFrom(pVecTernaryOp);
      })

      .Case<cir::WhileOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::WhileOp op) {
        protocir::CIRWhileOp pWhileOp;
        pInst.mutable_base()->set_id(instID);

        pInst.mutable_while_op()->CopyFrom(pWhileOp);
      })

      .Case<cir::YieldOp>([instID, &pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::YieldOp op) {
        protocir::CIRYieldOp pYieldOp;
        pInst.mutable_base()->set_id(instID);

        auto args = op.getArgs();
        for (auto eargs : args) {
          auto eargsProto = pYieldOp.add_args();
          auto eargsValue = Serializer::serializeValue(
              eargs, pModuleID, typeCache, opCache, blockCache);
          eargsProto->CopyFrom(eargsValue);
        }

        pInst.mutable_yield_op()->CopyFrom(pYieldOp);
      })

      .Default([](mlir::Operation *op) {
        op->dump();
        llvm_unreachable("NIY");
      });

  return pInst;
}
