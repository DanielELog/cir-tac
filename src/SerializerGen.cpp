/* Autogenerated by mlir-tblgen; don't manually edit. */

#include "cir-tac/Serializer.h"

#include <llvm/ADT/TypeSwitch.h>

using namespace protocir;

void Serializer::serializeOperation(mlir::Operation &inst,
                                    protocir::CIROp *pInst,
                                    protocir::CIRModuleID pModuleID,
                                    TypeCache &typeCache,
                                    OperationCache &opCache,
                                    BlockCache &blockCache,
                                    FunctionCache &functionCache

) {
  auto instID = internOperation(opCache, &inst);
  llvm::TypeSwitch<mlir::Operation *>(&inst)

      .Case<cir::AbsOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::AbsOp op) {
        protocir::CIRAbsOp pAbsOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pAbsOp.mutable_src() = psrcID;

        auto poison = op.getPoison();
        pAbsOp.set_poison(poison);

        pInst->mutable_abs_op()->CopyFrom(pAbsOp);
      })

      .Case<cir::AllocExceptionOp>([instID, pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::AllocExceptionOp op) {
        protocir::CIRAllocExceptionOp pAllocExceptionOp;
        pInst->mutable_base()->set_id(instID);

        auto size = op.getSize();
        pAllocExceptionOp.set_size(size);

        pInst->mutable_alloc_exception_op()->CopyFrom(pAllocExceptionOp);
      })

      .Case<cir::AllocaOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::AllocaOp op) {
        protocir::CIRAllocaOp pAllocaOp;
        pInst->mutable_base()->set_id(instID);

        auto dynAllocSize = op.getDynAllocSize().getDefiningOp();
        if (dynAllocSize) {
          auto dynAllocSizeID = internOperation(opCache, dynAllocSize);

          protocir::CIROpID pdynAllocSizeID;
          pdynAllocSizeID.set_id(dynAllocSizeID);

          *pAllocaOp.mutable_dyn_alloc_size() = pdynAllocSizeID;
        }

        auto allocaType = op.getAllocaType();
        auto allocaTypeID = internType(typeCache, allocaType);

        protocir::CIRTypeID pallocaTypeID;
        pallocaTypeID.set_id(allocaTypeID);

        *pAllocaOp.mutable_alloca_type() = pallocaTypeID;

        auto name = op.getName();
        *pAllocaOp.mutable_name() = name;

        auto init = op.getInit();
        pAllocaOp.set_init(init);

        auto constant = op.getConstant();
        pAllocaOp.set_constant(constant);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pAllocaOp.set_alignment(alignment);
        }

        pInst->mutable_alloca_op()->CopyFrom(pAllocaOp);
      })

      .Case<cir::ArrayCtor>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ArrayCtor op) {
        protocir::CIRArrayCtor pArrayCtor;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pArrayCtor.mutable_addr() = paddrID;

        pInst->mutable_array_ctor()->CopyFrom(pArrayCtor);
      })

      .Case<cir::ArrayDtor>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ArrayDtor op) {
        protocir::CIRArrayDtor pArrayDtor;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pArrayDtor.mutable_addr() = paddrID;

        pInst->mutable_array_dtor()->CopyFrom(pArrayDtor);
      })

      .Case<cir::AssumeAlignedOp>([instID, pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::AssumeAlignedOp op) {
        protocir::CIRAssumeAlignedOp pAssumeAlignedOp;
        pInst->mutable_base()->set_id(instID);

        auto pointer = op.getPointer().getDefiningOp();
        auto pointerID = internOperation(opCache, pointer);

        protocir::CIROpID ppointerID;
        ppointerID.set_id(pointerID);

        *pAssumeAlignedOp.mutable_pointer() = ppointerID;

        auto offset = op.getOffset().getDefiningOp();
        if (offset) {
          auto offsetID = internOperation(opCache, offset);

          protocir::CIROpID poffsetID;
          poffsetID.set_id(offsetID);

          *pAssumeAlignedOp.mutable_offset() = poffsetID;
        }

        auto alignment = op.getAlignment();
        pAssumeAlignedOp.set_alignment(alignment);

        pInst->mutable_assume_aligned_op()->CopyFrom(pAssumeAlignedOp);
      })

      .Case<cir::AssumeOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::AssumeOp op) {
        protocir::CIRAssumeOp pAssumeOp;
        pInst->mutable_base()->set_id(instID);

        auto predicate = op.getPredicate().getDefiningOp();
        auto predicateID = internOperation(opCache, predicate);

        protocir::CIROpID ppredicateID;
        ppredicateID.set_id(predicateID);

        *pAssumeOp.mutable_predicate() = ppredicateID;

        pInst->mutable_assume_op()->CopyFrom(pAssumeOp);
      })

      .Case<cir::AssumeSepStorageOp>([instID, pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::AssumeSepStorageOp op) {
        protocir::CIRAssumeSepStorageOp pAssumeSepStorageOp;
        pInst->mutable_base()->set_id(instID);

        auto ptr1 = op.getPtr1().getDefiningOp();
        auto ptr1ID = internOperation(opCache, ptr1);

        protocir::CIROpID pptr1ID;
        pptr1ID.set_id(ptr1ID);

        *pAssumeSepStorageOp.mutable_ptr1() = pptr1ID;

        auto ptr2 = op.getPtr2().getDefiningOp();
        auto ptr2ID = internOperation(opCache, ptr2);

        protocir::CIROpID pptr2ID;
        pptr2ID.set_id(ptr2ID);

        *pAssumeSepStorageOp.mutable_ptr2() = pptr2ID;

        pInst->mutable_assume_sep_storage_op()->CopyFrom(pAssumeSepStorageOp);
      })

      .Case<cir::AtomicCmpXchg>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::AtomicCmpXchg op) {
        protocir::CIRAtomicCmpXchg pAtomicCmpXchg;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pAtomicCmpXchg.mutable_ptr() = pptrID;

        auto expected = op.getExpected().getDefiningOp();
        auto expectedID = internOperation(opCache, expected);

        protocir::CIROpID pexpectedID;
        pexpectedID.set_id(expectedID);

        *pAtomicCmpXchg.mutable_expected() = pexpectedID;

        auto desired = op.getDesired().getDefiningOp();
        auto desiredID = internOperation(opCache, desired);

        protocir::CIROpID pdesiredID;
        pdesiredID.set_id(desiredID);

        *pAtomicCmpXchg.mutable_desired() = pdesiredID;

        auto weak = op.getWeak();
        pAtomicCmpXchg.set_weak(weak);

        auto isVolatile = op.getIsVolatile();
        pAtomicCmpXchg.set_is_volatile(isVolatile);

        pInst->mutable_atomic_cmp_xchg()->CopyFrom(pAtomicCmpXchg);
      })

      .Case<cir::AtomicFetch>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::AtomicFetch op) {
        protocir::CIRAtomicFetch pAtomicFetch;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pAtomicFetch.mutable_ptr() = pptrID;

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pAtomicFetch.mutable_val() = pvalID;

        auto isVolatile = op.getIsVolatile();
        pAtomicFetch.set_is_volatile(isVolatile);

        auto fetchFirst = op.getFetchFirst();
        pAtomicFetch.set_fetch_first(fetchFirst);

        pInst->mutable_atomic_fetch()->CopyFrom(pAtomicFetch);
      })

      .Case<cir::AtomicXchg>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::AtomicXchg op) {
        protocir::CIRAtomicXchg pAtomicXchg;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pAtomicXchg.mutable_ptr() = pptrID;

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pAtomicXchg.mutable_val() = pvalID;

        auto isVolatile = op.getIsVolatile();
        pAtomicXchg.set_is_volatile(isVolatile);

        pInst->mutable_atomic_xchg()->CopyFrom(pAtomicXchg);
      })

      .Case<cir::AwaitOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::AwaitOp op) {
        protocir::CIRAwaitOp pAwaitOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_await_op()->CopyFrom(pAwaitOp);
      })

      .Case<cir::BaseClassAddrOp>([instID, pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::BaseClassAddrOp op) {
        protocir::CIRBaseClassAddrOp pBaseClassAddrOp;
        pInst->mutable_base()->set_id(instID);

        auto derivedAddr = op.getDerivedAddr().getDefiningOp();
        auto derivedAddrID = internOperation(opCache, derivedAddr);

        protocir::CIROpID pderivedAddrID;
        pderivedAddrID.set_id(derivedAddrID);

        *pBaseClassAddrOp.mutable_derived_addr() = pderivedAddrID;

        llvm::SmallVector<char> offsetStr;
        auto offset = op.getOffset();
        offset.toString(offsetStr, 10, false);
        llvm::StringRef offsetStrRef(offsetStr.data(), offsetStr.size());
        *pBaseClassAddrOp.mutable_offset() = offsetStrRef;

        auto assumeNotNull = op.getAssumeNotNull();
        pBaseClassAddrOp.set_assume_not_null(assumeNotNull);

        pInst->mutable_base_class_addr_op()->CopyFrom(pBaseClassAddrOp);
      })

      .Case<cir::BinOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::BinOp op) {
        protocir::CIRBinOp pBinOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pBinOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pBinOp.mutable_rhs() = prhsID;

        auto noUnsignedWrap = op.getNoUnsignedWrap();
        pBinOp.set_no_unsigned_wrap(noUnsignedWrap);

        auto noSignedWrap = op.getNoSignedWrap();
        pBinOp.set_no_signed_wrap(noSignedWrap);

        pInst->mutable_bin_op()->CopyFrom(pBinOp);
      })

      .Case<cir::BinOpOverflowOp>([instID, pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::BinOpOverflowOp op) {
        protocir::CIRBinOpOverflowOp pBinOpOverflowOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pBinOpOverflowOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pBinOpOverflowOp.mutable_rhs() = prhsID;

        pInst->mutable_bin_op_overflow_op()->CopyFrom(pBinOpOverflowOp);
      })

      .Case<cir::BitClrsbOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::BitClrsbOp op) {
        protocir::CIRBitClrsbOp pBitClrsbOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitClrsbOp.mutable_input() = pinputID;

        pInst->mutable_bit_clrsb_op()->CopyFrom(pBitClrsbOp);
      })

      .Case<cir::BitClzOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitClzOp op) {
        protocir::CIRBitClzOp pBitClzOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitClzOp.mutable_input() = pinputID;

        pInst->mutable_bit_clz_op()->CopyFrom(pBitClzOp);
      })

      .Case<cir::BitCtzOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitCtzOp op) {
        protocir::CIRBitCtzOp pBitCtzOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitCtzOp.mutable_input() = pinputID;

        pInst->mutable_bit_ctz_op()->CopyFrom(pBitCtzOp);
      })

      .Case<cir::BitFfsOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BitFfsOp op) {
        protocir::CIRBitFfsOp pBitFfsOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitFfsOp.mutable_input() = pinputID;

        pInst->mutable_bit_ffs_op()->CopyFrom(pBitFfsOp);
      })

      .Case<cir::BitParityOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::BitParityOp op) {
        protocir::CIRBitParityOp pBitParityOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitParityOp.mutable_input() = pinputID;

        pInst->mutable_bit_parity_op()->CopyFrom(pBitParityOp);
      })

      .Case<cir::BitPopcountOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::BitPopcountOp op) {
        protocir::CIRBitPopcountOp pBitPopcountOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pBitPopcountOp.mutable_input() = pinputID;

        pInst->mutable_bit_popcount_op()->CopyFrom(pBitPopcountOp);
      })

      .Case<cir::BrCondOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::BrCondOp op) {
        protocir::CIRBrCondOp pBrCondOp;
        pInst->mutable_base()->set_id(instID);

        auto cond = op.getCond().getDefiningOp();
        auto condID = internOperation(opCache, cond);

        protocir::CIROpID pcondID;
        pcondID.set_id(condID);

        *pBrCondOp.mutable_cond() = pcondID;

        auto destOperandsTrue = op.getDestOperandsTrue();
        for (auto edestOperandsTrue : destOperandsTrue) {
          auto edestOperandsTrueProto = pBrCondOp.add_dest_operands_true();
          auto edestOperandsTrueID =
              internOperation(opCache, edestOperandsTrue.getDefiningOp());
          edestOperandsTrueProto->set_id(edestOperandsTrueID);
        }

        auto destOperandsFalse = op.getDestOperandsFalse();
        for (auto edestOperandsFalse : destOperandsFalse) {
          auto edestOperandsFalseProto = pBrCondOp.add_dest_operands_false();
          auto edestOperandsFalseID =
              internOperation(opCache, edestOperandsFalse.getDefiningOp());
          edestOperandsFalseProto->set_id(edestOperandsFalseID);
        }

        pInst->mutable_br_cond_op()->CopyFrom(pBrCondOp);
      })

      .Case<cir::BrOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                        &opCache](cir::BrOp op) {
        protocir::CIRBrOp pBrOp;
        pInst->mutable_base()->set_id(instID);

        auto destOperands = op.getDestOperands();
        for (auto edestOperands : destOperands) {
          auto edestOperandsProto = pBrOp.add_dest_operands();
          auto edestOperandsID =
              internOperation(opCache, edestOperands.getDefiningOp());
          edestOperandsProto->set_id(edestOperandsID);
        }

        pInst->mutable_br_op()->CopyFrom(pBrOp);
      })

      .Case<cir::BreakOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::BreakOp op) {
        protocir::CIRBreakOp pBreakOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_break_op()->CopyFrom(pBreakOp);
      })

      .Case<cir::ByteswapOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::ByteswapOp op) {
        protocir::CIRByteswapOp pByteswapOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pByteswapOp.mutable_input() = pinputID;

        pInst->mutable_byteswap_op()->CopyFrom(pByteswapOp);
      })

      .Case<cir::InlineAsmOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::InlineAsmOp op) {
        protocir::CIRInlineAsmOp pInlineAsmOp;
        pInst->mutable_base()->set_id(instID);

        auto operands = op.getOperands();
        for (auto eoperands : operands) {
          auto eoperandsProto = pInlineAsmOp.add_operands();
          for (auto eeoperands : eoperands) {
            auto eeoperandsProto = eoperandsProto->add_range();
            auto eeoperandsID =
                internOperation(opCache, eeoperands.getDefiningOp());
            eeoperandsProto->set_id(eeoperandsID);
          }
        }

        auto asmString = op.getAsmString();
        *pInlineAsmOp.mutable_asm_string() = asmString;

        auto constraints = op.getConstraints();
        *pInlineAsmOp.mutable_constraints() = constraints;

        auto sideEffects = op.getSideEffects();
        pInlineAsmOp.set_side_effects(sideEffects);

        auto operandsSegments = op.getOperandsSegments();
        for (auto eoperandsSegments : operandsSegments) {
          pInlineAsmOp.add_operands_segments(eoperandsSegments);
        }

        pInst->mutable_inline_asm_op()->CopyFrom(pInlineAsmOp);
      })

      .Case<cir::CallOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CallOp op) {
        protocir::CIRCallOp pCallOp;
        pInst->mutable_base()->set_id(instID);

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pCallOp.add_arg_ops();
          auto eargOpsID = internOperation(opCache, eargOps.getDefiningOp());
          eargOpsProto->set_id(eargOpsID);
        }

        auto exception = op.getException();
        pCallOp.set_exception(exception);

        auto calleeOptional = op.getCallee();
        if (calleeOptional) {
          auto callee = calleeOptional.value();
          *pCallOp.mutable_callee() = callee;
        }

        pInst->mutable_call_op()->CopyFrom(pCallOp);
      })

      .Case<cir::CaseOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CaseOp op) {
        protocir::CIRCaseOp pCaseOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_case_op()->CopyFrom(pCaseOp);
      })

      .Case<cir::CastOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CastOp op) {
        protocir::CIRCastOp pCastOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pCastOp.mutable_src() = psrcID;

        pInst->mutable_cast_op()->CopyFrom(pCastOp);
      })

      .Case<cir::CatchParamOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::CatchParamOp op) {
        protocir::CIRCatchParamOp pCatchParamOp;
        pInst->mutable_base()->set_id(instID);

        auto exceptionPtr = op.getExceptionPtr().getDefiningOp();
        if (exceptionPtr) {
          auto exceptionPtrID = internOperation(opCache, exceptionPtr);

          protocir::CIROpID pexceptionPtrID;
          pexceptionPtrID.set_id(exceptionPtrID);

          *pCatchParamOp.mutable_exception_ptr() = pexceptionPtrID;
        }

        pInst->mutable_catch_param_op()->CopyFrom(pCatchParamOp);
      })

      .Case<cir::CeilOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CeilOp op) {
        protocir::CIRCeilOp pCeilOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pCeilOp.mutable_src() = psrcID;

        pInst->mutable_ceil_op()->CopyFrom(pCeilOp);
      })

      .Case<cir::ClearCacheOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ClearCacheOp op) {
        protocir::CIRClearCacheOp pClearCacheOp;
        pInst->mutable_base()->set_id(instID);

        auto begin = op.getBegin().getDefiningOp();
        auto beginID = internOperation(opCache, begin);

        protocir::CIROpID pbeginID;
        pbeginID.set_id(beginID);

        *pClearCacheOp.mutable_begin() = pbeginID;

        auto end = op.getEnd().getDefiningOp();
        auto endID = internOperation(opCache, end);

        protocir::CIROpID pendID;
        pendID.set_id(endID);

        *pClearCacheOp.mutable_end() = pendID;

        pInst->mutable_clear_cache_op()->CopyFrom(pClearCacheOp);
      })

      .Case<cir::CmpOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::CmpOp op) {
        protocir::CIRCmpOp pCmpOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pCmpOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pCmpOp.mutable_rhs() = prhsID;

        pInst->mutable_cmp_op()->CopyFrom(pCmpOp);
      })

      .Case<cir::CmpThreeWayOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::CmpThreeWayOp op) {
        protocir::CIRCmpThreeWayOp pCmpThreeWayOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pCmpThreeWayOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pCmpThreeWayOp.mutable_rhs() = prhsID;

        pInst->mutable_cmp_three_way_op()->CopyFrom(pCmpThreeWayOp);
      })

      .Case<cir::ComplexBinOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ComplexBinOp op) {
        protocir::CIRComplexBinOp pComplexBinOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pComplexBinOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pComplexBinOp.mutable_rhs() = prhsID;

        auto promoted = op.getPromoted();
        pComplexBinOp.set_promoted(promoted);

        pInst->mutable_complex_bin_op()->CopyFrom(pComplexBinOp);
      })

      .Case<cir::ComplexCreateOp>([instID, pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::ComplexCreateOp op) {
        protocir::CIRComplexCreateOp pComplexCreateOp;
        pInst->mutable_base()->set_id(instID);

        auto real = op.getReal().getDefiningOp();
        auto realID = internOperation(opCache, real);

        protocir::CIROpID prealID;
        prealID.set_id(realID);

        *pComplexCreateOp.mutable_real() = prealID;

        auto imag = op.getImag().getDefiningOp();
        auto imagID = internOperation(opCache, imag);

        protocir::CIROpID pimagID;
        pimagID.set_id(imagID);

        *pComplexCreateOp.mutable_imag() = pimagID;

        pInst->mutable_complex_create_op()->CopyFrom(pComplexCreateOp);
      })

      .Case<cir::ComplexImagOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::ComplexImagOp op) {
        protocir::CIRComplexImagOp pComplexImagOp;
        pInst->mutable_base()->set_id(instID);

        auto operand = op.getOperand().getDefiningOp();
        auto operandID = internOperation(opCache, operand);

        protocir::CIROpID poperandID;
        poperandID.set_id(operandID);

        *pComplexImagOp.mutable_operand() = poperandID;

        pInst->mutable_complex_imag_op()->CopyFrom(pComplexImagOp);
      })

      .Case<cir::ComplexImagPtrOp>([instID, pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::ComplexImagPtrOp op) {
        protocir::CIRComplexImagPtrOp pComplexImagPtrOp;
        pInst->mutable_base()->set_id(instID);

        auto operand = op.getOperand().getDefiningOp();
        auto operandID = internOperation(opCache, operand);

        protocir::CIROpID poperandID;
        poperandID.set_id(operandID);

        *pComplexImagPtrOp.mutable_operand() = poperandID;

        pInst->mutable_complex_imag_ptr_op()->CopyFrom(pComplexImagPtrOp);
      })

      .Case<cir::ComplexRealOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::ComplexRealOp op) {
        protocir::CIRComplexRealOp pComplexRealOp;
        pInst->mutable_base()->set_id(instID);

        auto operand = op.getOperand().getDefiningOp();
        auto operandID = internOperation(opCache, operand);

        protocir::CIROpID poperandID;
        poperandID.set_id(operandID);

        *pComplexRealOp.mutable_operand() = poperandID;

        pInst->mutable_complex_real_op()->CopyFrom(pComplexRealOp);
      })

      .Case<cir::ComplexRealPtrOp>([instID, pInst, pModuleID, &typeCache,
                                    &blockCache,
                                    &opCache](cir::ComplexRealPtrOp op) {
        protocir::CIRComplexRealPtrOp pComplexRealPtrOp;
        pInst->mutable_base()->set_id(instID);

        auto operand = op.getOperand().getDefiningOp();
        auto operandID = internOperation(opCache, operand);

        protocir::CIROpID poperandID;
        poperandID.set_id(operandID);

        *pComplexRealPtrOp.mutable_operand() = poperandID;

        pInst->mutable_complex_real_ptr_op()->CopyFrom(pComplexRealPtrOp);
      })

      .Case<cir::ConditionOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::ConditionOp op) {
        protocir::CIRConditionOp pConditionOp;
        pInst->mutable_base()->set_id(instID);

        auto condition = op.getCondition().getDefiningOp();
        auto conditionID = internOperation(opCache, condition);

        protocir::CIROpID pconditionID;
        pconditionID.set_id(conditionID);

        *pConditionOp.mutable_condition() = pconditionID;

        pInst->mutable_condition_op()->CopyFrom(pConditionOp);
      })

      .Case<cir::ConstantOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::ConstantOp op) {
        protocir::CIRConstantOp pConstantOp;
        pInst->mutable_base()->set_id(instID);

        std::string valueStr;
        llvm::raw_string_ostream valueRawStream(valueStr);
        op.getValue().print(valueRawStream);
        *pConstantOp.mutable_value() = valueStr;

        pInst->mutable_constant_op()->CopyFrom(pConstantOp);
      })

      .Case<cir::ContinueOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::ContinueOp op) {
        protocir::CIRContinueOp pContinueOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_continue_op()->CopyFrom(pContinueOp);
      })

      .Case<cir::CopyOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::CopyOp op) {
        protocir::CIRCopyOp pCopyOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pCopyOp.mutable_dst() = pdstID;

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pCopyOp.mutable_src() = psrcID;

        auto isVolatile = op.getIsVolatile();
        pCopyOp.set_is_volatile(isVolatile);

        pInst->mutable_copy_op()->CopyFrom(pCopyOp);
      })

      .Case<cir::CopysignOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::CopysignOp op) {
        protocir::CIRCopysignOp pCopysignOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pCopysignOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pCopysignOp.mutable_rhs() = prhsID;

        pInst->mutable_copysign_op()->CopyFrom(pCopysignOp);
      })

      .Case<cir::CosOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::CosOp op) {
        protocir::CIRCosOp pCosOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pCosOp.mutable_src() = psrcID;

        pInst->mutable_cos_op()->CopyFrom(pCosOp);
      })

      .Case<cir::DerivedClassAddrOp>([instID, pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::DerivedClassAddrOp op) {
        protocir::CIRDerivedClassAddrOp pDerivedClassAddrOp;
        pInst->mutable_base()->set_id(instID);

        auto baseAddr = op.getBaseAddr().getDefiningOp();
        auto baseAddrID = internOperation(opCache, baseAddr);

        protocir::CIROpID pbaseAddrID;
        pbaseAddrID.set_id(baseAddrID);

        *pDerivedClassAddrOp.mutable_base_addr() = pbaseAddrID;

        llvm::SmallVector<char> offsetStr;
        auto offset = op.getOffset();
        offset.toString(offsetStr, 10, false);
        llvm::StringRef offsetStrRef(offsetStr.data(), offsetStr.size());
        *pDerivedClassAddrOp.mutable_offset() = offsetStrRef;

        auto assumeNotNull = op.getAssumeNotNull();
        pDerivedClassAddrOp.set_assume_not_null(assumeNotNull);

        pInst->mutable_derived_class_addr_op()->CopyFrom(pDerivedClassAddrOp);
      })

      .Case<cir::DoWhileOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::DoWhileOp op) {
        protocir::CIRDoWhileOp pDoWhileOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_do_while_op()->CopyFrom(pDoWhileOp);
      })

      .Case<cir::DynamicCastOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::DynamicCastOp op) {
        protocir::CIRDynamicCastOp pDynamicCastOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pDynamicCastOp.mutable_src() = psrcID;

        auto relativeLayout = op.getRelativeLayout();
        pDynamicCastOp.set_relative_layout(relativeLayout);

        pInst->mutable_dynamic_cast_op()->CopyFrom(pDynamicCastOp);
      })

      .Case<cir::EhInflightOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::EhInflightOp op) {
        protocir::CIREhInflightOp pEhInflightOp;
        pInst->mutable_base()->set_id(instID);

        auto cleanup = op.getCleanup();
        pEhInflightOp.set_cleanup(cleanup);

        pInst->mutable_eh_inflight_op()->CopyFrom(pEhInflightOp);
      })

      .Case<cir::EhTypeIdOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::EhTypeIdOp op) {
        protocir::CIREhTypeIdOp pEhTypeIdOp;
        pInst->mutable_base()->set_id(instID);

        auto typeSym = op.getTypeSym();
        *pEhTypeIdOp.mutable_type_sym() = typeSym;

        pInst->mutable_eh_type_id_op()->CopyFrom(pEhTypeIdOp);
      })

      .Case<cir::Exp2Op>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::Exp2Op op) {
        protocir::CIRExp2Op pExp2Op;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pExp2Op.mutable_src() = psrcID;

        pInst->mutable_exp2_op()->CopyFrom(pExp2Op);
      })

      .Case<cir::ExpOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::ExpOp op) {
        protocir::CIRExpOp pExpOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pExpOp.mutable_src() = psrcID;

        pInst->mutable_exp_op()->CopyFrom(pExpOp);
      })

      .Case<cir::ExpectOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ExpectOp op) {
        protocir::CIRExpectOp pExpectOp;
        pInst->mutable_base()->set_id(instID);

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pExpectOp.mutable_val() = pvalID;

        auto expected = op.getExpected().getDefiningOp();
        auto expectedID = internOperation(opCache, expected);

        protocir::CIROpID pexpectedID;
        pexpectedID.set_id(expectedID);

        *pExpectOp.mutable_expected() = pexpectedID;

        auto probOptional = op.getProb();
        if (probOptional) {
          auto prob = probOptional.value();
          llvm::SmallVector<char> probStr;
          prob.toString(probStr);
          llvm::StringRef probStrRef(probStr.data(), probStr.size());
          *pExpectOp.mutable_prob() = probStrRef;
        }

        pInst->mutable_expect_op()->CopyFrom(pExpectOp);
      })

      .Case<cir::FAbsOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FAbsOp op) {
        protocir::CIRFAbsOp pFAbsOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pFAbsOp.mutable_src() = psrcID;

        pInst->mutable_f_abs_op()->CopyFrom(pFAbsOp);
      })

      .Case<cir::FMaxOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FMaxOp op) {
        protocir::CIRFMaxOp pFMaxOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pFMaxOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pFMaxOp.mutable_rhs() = prhsID;

        pInst->mutable_f_max_op()->CopyFrom(pFMaxOp);
      })

      .Case<cir::FMinOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FMinOp op) {
        protocir::CIRFMinOp pFMinOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pFMinOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pFMinOp.mutable_rhs() = prhsID;

        pInst->mutable_f_min_op()->CopyFrom(pFMinOp);
      })

      .Case<cir::FModOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FModOp op) {
        protocir::CIRFModOp pFModOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pFModOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pFModOp.mutable_rhs() = prhsID;

        pInst->mutable_f_mod_op()->CopyFrom(pFModOp);
      })

      .Case<cir::FloorOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::FloorOp op) {
        protocir::CIRFloorOp pFloorOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pFloorOp.mutable_src() = psrcID;

        pInst->mutable_floor_op()->CopyFrom(pFloorOp);
      })

      .Case<cir::ForOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::ForOp op) {
        protocir::CIRForOp pForOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_for_op()->CopyFrom(pForOp);
      })

      .Case<cir::FrameAddrOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::FrameAddrOp op) {
        protocir::CIRFrameAddrOp pFrameAddrOp;
        pInst->mutable_base()->set_id(instID);

        auto level = op.getLevel().getDefiningOp();
        auto levelID = internOperation(opCache, level);

        protocir::CIROpID plevelID;
        plevelID.set_id(levelID);

        *pFrameAddrOp.mutable_level() = plevelID;

        pInst->mutable_frame_addr_op()->CopyFrom(pFrameAddrOp);
      })

      .Case<cir::FreeExceptionOp>([instID, pInst, pModuleID, &typeCache,
                                   &blockCache,
                                   &opCache](cir::FreeExceptionOp op) {
        protocir::CIRFreeExceptionOp pFreeExceptionOp;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pFreeExceptionOp.mutable_ptr() = pptrID;

        pInst->mutable_free_exception_op()->CopyFrom(pFreeExceptionOp);
      })

      .Case<cir::FuncOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::FuncOp op) {
        protocir::CIRFuncOp pFuncOp;
        pInst->mutable_base()->set_id(instID);

        auto symName = op.getSymName();
        *pFuncOp.mutable_sym_name() = symName;

        auto globalVisibility = op.getGlobalVisibility();
        *pFuncOp.mutable_global_visibility() = globalVisibility;

        auto functionType = op.getFunctionType();
        auto functionTypeID = internType(typeCache, functionType);

        protocir::CIRTypeID pfunctionTypeID;
        pfunctionTypeID.set_id(functionTypeID);

        *pFuncOp.mutable_function_type() = pfunctionTypeID;

        auto builtin = op.getBuiltin();
        pFuncOp.set_builtin(builtin);

        auto coroutine = op.getCoroutine();
        pFuncOp.set_coroutine(coroutine);

        auto lambda = op.getLambda();
        pFuncOp.set_lambda(lambda);

        auto noProto = op.getNoProto();
        pFuncOp.set_no_proto(noProto);

        auto dsolocal = op.getDsolocal();
        pFuncOp.set_dsolocal(dsolocal);

        auto symVisibilityOptional = op.getSymVisibility();
        if (symVisibilityOptional) {
          auto symVisibility = symVisibilityOptional.value();
          *pFuncOp.mutable_sym_visibility() = symVisibility;
        }

        auto comdat = op.getComdat();
        pFuncOp.set_comdat(comdat);

        auto aliaseeOptional = op.getAliasee();
        if (aliaseeOptional) {
          auto aliasee = aliaseeOptional.value();
          *pFuncOp.mutable_aliasee() = aliasee;
        }

        auto globalCtorOptional = op.getGlobalCtor();
        pFuncOp.set_global_ctor(globalCtorOptional.has_value());

        auto globalDtorOptional = op.getGlobalDtor();
        pFuncOp.set_global_dtor(globalDtorOptional.has_value());

        pInst->mutable_func_op()->CopyFrom(pFuncOp);
      })

      .Case<cir::GetBitfieldOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::GetBitfieldOp op) {
        protocir::CIRGetBitfieldOp pGetBitfieldOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pGetBitfieldOp.mutable_addr() = paddrID;

        auto isVolatile = op.getIsVolatile();
        pGetBitfieldOp.set_is_volatile(isVolatile);

        pInst->mutable_get_bitfield_op()->CopyFrom(pGetBitfieldOp);
      })

      .Case<cir::GetGlobalOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetGlobalOp op) {
        protocir::CIRGetGlobalOp pGetGlobalOp;
        pInst->mutable_base()->set_id(instID);

        auto name = op.getName();
        *pGetGlobalOp.mutable_name() = name;

        auto tls = op.getTls();
        pGetGlobalOp.set_tls(tls);

        pInst->mutable_get_global_op()->CopyFrom(pGetGlobalOp);
      })

      .Case<cir::GetMemberOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetMemberOp op) {
        protocir::CIRGetMemberOp pGetMemberOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pGetMemberOp.mutable_addr() = paddrID;

        auto name = op.getName();
        *pGetMemberOp.mutable_name() = name;

        llvm::SmallVector<char> indexAttrStr;
        auto indexAttr = op.getIndexAttr();
        indexAttr.toString(indexAttrStr, 10, false);
        llvm::StringRef indexAttrStrRef(indexAttrStr.data(),
                                        indexAttrStr.size());
        *pGetMemberOp.mutable_index_attr() = indexAttrStrRef;

        pInst->mutable_get_member_op()->CopyFrom(pGetMemberOp);
      })

      .Case<cir::GetMethodOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::GetMethodOp op) {
        protocir::CIRGetMethodOp pGetMethodOp;
        pInst->mutable_base()->set_id(instID);

        auto method = op.getMethod().getDefiningOp();
        auto methodID = internOperation(opCache, method);

        protocir::CIROpID pmethodID;
        pmethodID.set_id(methodID);

        *pGetMethodOp.mutable_method() = pmethodID;

        auto object = op.getObject().getDefiningOp();
        auto objectID = internOperation(opCache, object);

        protocir::CIROpID pobjectID;
        pobjectID.set_id(objectID);

        *pGetMethodOp.mutable_object() = pobjectID;

        pInst->mutable_get_method_op()->CopyFrom(pGetMethodOp);
      })

      .Case<cir::GetRuntimeMemberOp>([instID, pInst, pModuleID, &typeCache,
                                      &blockCache,
                                      &opCache](cir::GetRuntimeMemberOp op) {
        protocir::CIRGetRuntimeMemberOp pGetRuntimeMemberOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pGetRuntimeMemberOp.mutable_addr() = paddrID;

        auto member = op.getMember().getDefiningOp();
        auto memberID = internOperation(opCache, member);

        protocir::CIROpID pmemberID;
        pmemberID.set_id(memberID);

        *pGetRuntimeMemberOp.mutable_member() = pmemberID;

        pInst->mutable_get_runtime_member_op()->CopyFrom(pGetRuntimeMemberOp);
      })

      .Case<cir::GlobalOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::GlobalOp op) {
        protocir::CIRGlobalOp pGlobalOp;
        pInst->mutable_base()->set_id(instID);

        auto symName = op.getSymName();
        *pGlobalOp.mutable_sym_name() = symName;

        auto globalVisibility = op.getGlobalVisibility();
        *pGlobalOp.mutable_global_visibility() = globalVisibility;

        auto symVisibilityOptional = op.getSymVisibility();
        if (symVisibilityOptional) {
          auto symVisibility = symVisibilityOptional.value();
          *pGlobalOp.mutable_sym_visibility() = symVisibility;
        }

        auto symType = op.getSymType();
        auto symTypeID = internType(typeCache, symType);

        protocir::CIRTypeID psymTypeID;
        psymTypeID.set_id(symTypeID);

        *pGlobalOp.mutable_sym_type() = psymTypeID;

        auto comdat = op.getComdat();
        pGlobalOp.set_comdat(comdat);

        auto constant = op.getConstant();
        pGlobalOp.set_constant(constant);

        auto dsolocal = op.getDsolocal();
        pGlobalOp.set_dsolocal(dsolocal);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pGlobalOp.set_alignment(alignment);
        }

        auto sectionOptional = op.getSection();
        if (sectionOptional) {
          auto section = sectionOptional.value();
          *pGlobalOp.mutable_section() = section;
        }

        pInst->mutable_global_op()->CopyFrom(pGlobalOp);
      })

      .Case<cir::GotoOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::GotoOp op) {
        protocir::CIRGotoOp pGotoOp;
        pInst->mutable_base()->set_id(instID);

        auto label = op.getLabel();
        *pGotoOp.mutable_label() = label;

        pInst->mutable_goto_op()->CopyFrom(pGotoOp);
      })

      .Case<cir::IfOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                        &opCache](cir::IfOp op) {
        protocir::CIRIfOp pIfOp;
        pInst->mutable_base()->set_id(instID);

        auto condition = op.getCondition().getDefiningOp();
        auto conditionID = internOperation(opCache, condition);

        protocir::CIROpID pconditionID;
        pconditionID.set_id(conditionID);

        *pIfOp.mutable_condition() = pconditionID;

        pInst->mutable_if_op()->CopyFrom(pIfOp);
      })

      .Case<cir::IsConstantOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::IsConstantOp op) {
        protocir::CIRIsConstantOp pIsConstantOp;
        pInst->mutable_base()->set_id(instID);

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pIsConstantOp.mutable_val() = pvalID;

        pInst->mutable_is_constant_op()->CopyFrom(pIsConstantOp);
      })

      .Case<cir::IsFPClassOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::IsFPClassOp op) {
        protocir::CIRIsFPClassOp pIsFPClassOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pIsFPClassOp.mutable_src() = psrcID;

        auto flags = op.getFlags();
        pIsFPClassOp.set_flags(flags);

        pInst->mutable_is_fp_class_op()->CopyFrom(pIsFPClassOp);
      })

      .Case<cir::IterBeginOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::IterBeginOp op) {
        protocir::CIRIterBeginOp pIterBeginOp;
        pInst->mutable_base()->set_id(instID);

        auto container = op.getContainer().getDefiningOp();
        auto containerID = internOperation(opCache, container);

        protocir::CIROpID pcontainerID;
        pcontainerID.set_id(containerID);

        *pIterBeginOp.mutable_container() = pcontainerID;

        auto originalFn = op.getOriginalFn();
        *pIterBeginOp.mutable_original_fn() = originalFn;

        pInst->mutable_iter_begin_op()->CopyFrom(pIterBeginOp);
      })

      .Case<cir::IterEndOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::IterEndOp op) {
        protocir::CIRIterEndOp pIterEndOp;
        pInst->mutable_base()->set_id(instID);

        auto container = op.getContainer().getDefiningOp();
        auto containerID = internOperation(opCache, container);

        protocir::CIROpID pcontainerID;
        pcontainerID.set_id(containerID);

        *pIterEndOp.mutable_container() = pcontainerID;

        auto originalFn = op.getOriginalFn();
        *pIterEndOp.mutable_original_fn() = originalFn;

        pInst->mutable_iter_end_op()->CopyFrom(pIterEndOp);
      })

      .Case<cir::LLVMIntrinsicCallOp>([instID, pInst, pModuleID, &typeCache,
                                       &blockCache,
                                       &opCache](cir::LLVMIntrinsicCallOp op) {
        protocir::CIRLLVMIntrinsicCallOp pLLVMIntrinsicCallOp;
        pInst->mutable_base()->set_id(instID);

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pLLVMIntrinsicCallOp.add_arg_ops();
          auto eargOpsID = internOperation(opCache, eargOps.getDefiningOp());
          eargOpsProto->set_id(eargOpsID);
        }

        auto intrinsicName = op.getIntrinsicName();
        *pLLVMIntrinsicCallOp.mutable_intrinsic_name() = intrinsicName;

        pInst->mutable_llvm_intrinsic_call_op()->CopyFrom(pLLVMIntrinsicCallOp);
      })

      .Case<cir::LLrintOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::LLrintOp op) {
        protocir::CIRLLrintOp pLLrintOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLLrintOp.mutable_src() = psrcID;

        pInst->mutable_l_lrint_op()->CopyFrom(pLLrintOp);
      })

      .Case<cir::LLroundOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::LLroundOp op) {
        protocir::CIRLLroundOp pLLroundOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLLroundOp.mutable_src() = psrcID;

        pInst->mutable_l_lround_op()->CopyFrom(pLLroundOp);
      })

      .Case<cir::LabelOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::LabelOp op) {
        protocir::CIRLabelOp pLabelOp;
        pInst->mutable_base()->set_id(instID);

        auto label = op.getLabel();
        *pLabelOp.mutable_label() = label;

        pInst->mutable_label_op()->CopyFrom(pLabelOp);
      })

      .Case<cir::LoadOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::LoadOp op) {
        protocir::CIRLoadOp pLoadOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pLoadOp.mutable_addr() = paddrID;

        auto isDeref = op.getIsDeref();
        pLoadOp.set_is_deref(isDeref);

        auto isVolatile = op.getIsVolatile();
        pLoadOp.set_is_volatile(isVolatile);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pLoadOp.set_alignment(alignment);
        }

        pInst->mutable_load_op()->CopyFrom(pLoadOp);
      })

      .Case<cir::Log10Op>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::Log10Op op) {
        protocir::CIRLog10Op pLog10Op;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLog10Op.mutable_src() = psrcID;

        pInst->mutable_log10_op()->CopyFrom(pLog10Op);
      })

      .Case<cir::Log2Op>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::Log2Op op) {
        protocir::CIRLog2Op pLog2Op;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLog2Op.mutable_src() = psrcID;

        pInst->mutable_log2_op()->CopyFrom(pLog2Op);
      })

      .Case<cir::LogOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::LogOp op) {
        protocir::CIRLogOp pLogOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLogOp.mutable_src() = psrcID;

        pInst->mutable_log_op()->CopyFrom(pLogOp);
      })

      .Case<cir::LrintOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::LrintOp op) {
        protocir::CIRLrintOp pLrintOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLrintOp.mutable_src() = psrcID;

        pInst->mutable_lrint_op()->CopyFrom(pLrintOp);
      })

      .Case<cir::LroundOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::LroundOp op) {
        protocir::CIRLroundOp pLroundOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pLroundOp.mutable_src() = psrcID;

        pInst->mutable_lround_op()->CopyFrom(pLroundOp);
      })

      .Case<cir::MemChrOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemChrOp op) {
        protocir::CIRMemChrOp pMemChrOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pMemChrOp.mutable_src() = psrcID;

        auto pattern = op.getPattern().getDefiningOp();
        auto patternID = internOperation(opCache, pattern);

        protocir::CIROpID ppatternID;
        ppatternID.set_id(patternID);

        *pMemChrOp.mutable_pattern() = ppatternID;

        auto len = op.getLen().getDefiningOp();
        auto lenID = internOperation(opCache, len);

        protocir::CIROpID plenID;
        plenID.set_id(lenID);

        *pMemChrOp.mutable_len() = plenID;

        pInst->mutable_mem_chr_op()->CopyFrom(pMemChrOp);
      })

      .Case<cir::MemCpyInlineOp>([instID, pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::MemCpyInlineOp op) {
        protocir::CIRMemCpyInlineOp pMemCpyInlineOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pMemCpyInlineOp.mutable_dst() = pdstID;

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pMemCpyInlineOp.mutable_src() = psrcID;

        auto len = op.getLen();
        pMemCpyInlineOp.set_len(len);

        pInst->mutable_mem_cpy_inline_op()->CopyFrom(pMemCpyInlineOp);
      })

      .Case<cir::MemCpyOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemCpyOp op) {
        protocir::CIRMemCpyOp pMemCpyOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pMemCpyOp.mutable_dst() = pdstID;

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pMemCpyOp.mutable_src() = psrcID;

        auto len = op.getLen().getDefiningOp();
        auto lenID = internOperation(opCache, len);

        protocir::CIROpID plenID;
        plenID.set_id(lenID);

        *pMemCpyOp.mutable_len() = plenID;

        pInst->mutable_mem_cpy_op()->CopyFrom(pMemCpyOp);
      })

      .Case<cir::MemMoveOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::MemMoveOp op) {
        protocir::CIRMemMoveOp pMemMoveOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pMemMoveOp.mutable_dst() = pdstID;

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pMemMoveOp.mutable_src() = psrcID;

        auto len = op.getLen().getDefiningOp();
        auto lenID = internOperation(opCache, len);

        protocir::CIROpID plenID;
        plenID.set_id(lenID);

        *pMemMoveOp.mutable_len() = plenID;

        pInst->mutable_mem_move_op()->CopyFrom(pMemMoveOp);
      })

      .Case<cir::MemSetInlineOp>([instID, pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::MemSetInlineOp op) {
        protocir::CIRMemSetInlineOp pMemSetInlineOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pMemSetInlineOp.mutable_dst() = pdstID;

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pMemSetInlineOp.mutable_val() = pvalID;

        auto len = op.getLen();
        pMemSetInlineOp.set_len(len);

        pInst->mutable_mem_set_inline_op()->CopyFrom(pMemSetInlineOp);
      })

      .Case<cir::MemSetOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::MemSetOp op) {
        protocir::CIRMemSetOp pMemSetOp;
        pInst->mutable_base()->set_id(instID);

        auto dst = op.getDst().getDefiningOp();
        auto dstID = internOperation(opCache, dst);

        protocir::CIROpID pdstID;
        pdstID.set_id(dstID);

        *pMemSetOp.mutable_dst() = pdstID;

        auto val = op.getVal().getDefiningOp();
        auto valID = internOperation(opCache, val);

        protocir::CIROpID pvalID;
        pvalID.set_id(valID);

        *pMemSetOp.mutable_val() = pvalID;

        auto len = op.getLen().getDefiningOp();
        auto lenID = internOperation(opCache, len);

        protocir::CIROpID plenID;
        plenID.set_id(lenID);

        *pMemSetOp.mutable_len() = plenID;

        pInst->mutable_mem_set_op()->CopyFrom(pMemSetOp);
      })

      .Case<cir::NearbyintOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::NearbyintOp op) {
        protocir::CIRNearbyintOp pNearbyintOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pNearbyintOp.mutable_src() = psrcID;

        pInst->mutable_nearbyint_op()->CopyFrom(pNearbyintOp);
      })

      .Case<cir::ObjSizeOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::ObjSizeOp op) {
        protocir::CIRObjSizeOp pObjSizeOp;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pObjSizeOp.mutable_ptr() = pptrID;

        auto dynamic = op.getDynamic();
        pObjSizeOp.set_dynamic(dynamic);

        pInst->mutable_obj_size_op()->CopyFrom(pObjSizeOp);
      })

      .Case<cir::PowOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::PowOp op) {
        protocir::CIRPowOp pPowOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pPowOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pPowOp.mutable_rhs() = prhsID;

        pInst->mutable_pow_op()->CopyFrom(pPowOp);
      })

      .Case<cir::PrefetchOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::PrefetchOp op) {
        protocir::CIRPrefetchOp pPrefetchOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pPrefetchOp.mutable_addr() = paddrID;

        auto locality = op.getLocality();
        pPrefetchOp.set_locality(locality);

        auto isWrite = op.getIsWrite();
        pPrefetchOp.set_is_write(isWrite);

        pInst->mutable_prefetch_op()->CopyFrom(pPrefetchOp);
      })

      .Case<cir::PtrDiffOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::PtrDiffOp op) {
        protocir::CIRPtrDiffOp pPtrDiffOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pPtrDiffOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pPtrDiffOp.mutable_rhs() = prhsID;

        pInst->mutable_ptr_diff_op()->CopyFrom(pPtrDiffOp);
      })

      .Case<cir::PtrMaskOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::PtrMaskOp op) {
        protocir::CIRPtrMaskOp pPtrMaskOp;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pPtrMaskOp.mutable_ptr() = pptrID;

        auto mask = op.getMask().getDefiningOp();
        auto maskID = internOperation(opCache, mask);

        protocir::CIROpID pmaskID;
        pmaskID.set_id(maskID);

        *pPtrMaskOp.mutable_mask() = pmaskID;

        pInst->mutable_ptr_mask_op()->CopyFrom(pPtrMaskOp);
      })

      .Case<cir::PtrStrideOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::PtrStrideOp op) {
        protocir::CIRPtrStrideOp pPtrStrideOp;
        pInst->mutable_base()->set_id(instID);

        auto base = op.getBase().getDefiningOp();
        auto baseID = internOperation(opCache, base);

        protocir::CIROpID pbaseID;
        pbaseID.set_id(baseID);

        *pPtrStrideOp.mutable_base() = pbaseID;

        auto stride = op.getStride().getDefiningOp();
        auto strideID = internOperation(opCache, stride);

        protocir::CIROpID pstrideID;
        pstrideID.set_id(strideID);

        *pPtrStrideOp.mutable_stride() = pstrideID;

        pInst->mutable_ptr_stride_op()->CopyFrom(pPtrStrideOp);
      })

      .Case<cir::ResumeOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ResumeOp op) {
        protocir::CIRResumeOp pResumeOp;
        pInst->mutable_base()->set_id(instID);

        auto exceptionPtr = op.getExceptionPtr().getDefiningOp();
        if (exceptionPtr) {
          auto exceptionPtrID = internOperation(opCache, exceptionPtr);

          protocir::CIROpID pexceptionPtrID;
          pexceptionPtrID.set_id(exceptionPtrID);

          *pResumeOp.mutable_exception_ptr() = pexceptionPtrID;
        }

        auto typeId = op.getTypeId().getDefiningOp();
        if (typeId) {
          auto typeIdID = internOperation(opCache, typeId);

          protocir::CIROpID ptypeIdID;
          ptypeIdID.set_id(typeIdID);

          *pResumeOp.mutable_type_id() = ptypeIdID;
        }

        auto rethrow = op.getRethrow();
        pResumeOp.set_rethrow(rethrow);

        pInst->mutable_resume_op()->CopyFrom(pResumeOp);
      })

      .Case<cir::ReturnAddrOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::ReturnAddrOp op) {
        protocir::CIRReturnAddrOp pReturnAddrOp;
        pInst->mutable_base()->set_id(instID);

        auto level = op.getLevel().getDefiningOp();
        auto levelID = internOperation(opCache, level);

        protocir::CIROpID plevelID;
        plevelID.set_id(levelID);

        *pReturnAddrOp.mutable_level() = plevelID;

        pInst->mutable_return_addr_op()->CopyFrom(pReturnAddrOp);
      })

      .Case<cir::ReturnOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::ReturnOp op) {
        protocir::CIRReturnOp pReturnOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput();
        for (auto einput : input) {
          auto einputProto = pReturnOp.add_input();
          auto einputID = internOperation(opCache, einput.getDefiningOp());
          einputProto->set_id(einputID);
        }

        pInst->mutable_return_op()->CopyFrom(pReturnOp);
      })

      .Case<cir::RintOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::RintOp op) {
        protocir::CIRRintOp pRintOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pRintOp.mutable_src() = psrcID;

        pInst->mutable_rint_op()->CopyFrom(pRintOp);
      })

      .Case<cir::RotateOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::RotateOp op) {
        protocir::CIRRotateOp pRotateOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pRotateOp.mutable_src() = psrcID;

        auto amt = op.getAmt().getDefiningOp();
        auto amtID = internOperation(opCache, amt);

        protocir::CIROpID pamtID;
        pamtID.set_id(amtID);

        *pRotateOp.mutable_amt() = pamtID;

        auto left = op.getLeft();
        pRotateOp.set_left(left);

        pInst->mutable_rotate_op()->CopyFrom(pRotateOp);
      })

      .Case<cir::RoundOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::RoundOp op) {
        protocir::CIRRoundOp pRoundOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pRoundOp.mutable_src() = psrcID;

        pInst->mutable_round_op()->CopyFrom(pRoundOp);
      })

      .Case<cir::ScopeOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ScopeOp op) {
        protocir::CIRScopeOp pScopeOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_scope_op()->CopyFrom(pScopeOp);
      })

      .Case<cir::SelectOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::SelectOp op) {
        protocir::CIRSelectOp pSelectOp;
        pInst->mutable_base()->set_id(instID);

        auto condition = op.getCondition().getDefiningOp();
        auto conditionID = internOperation(opCache, condition);

        protocir::CIROpID pconditionID;
        pconditionID.set_id(conditionID);

        *pSelectOp.mutable_condition() = pconditionID;

        auto trueValue = op.getTrueValue().getDefiningOp();
        auto trueValueID = internOperation(opCache, trueValue);

        protocir::CIROpID ptrueValueID;
        ptrueValueID.set_id(trueValueID);

        *pSelectOp.mutable_true_value() = ptrueValueID;

        auto falseValue = op.getFalseValue().getDefiningOp();
        auto falseValueID = internOperation(opCache, falseValue);

        protocir::CIROpID pfalseValueID;
        pfalseValueID.set_id(falseValueID);

        *pSelectOp.mutable_false_value() = pfalseValueID;

        pInst->mutable_select_op()->CopyFrom(pSelectOp);
      })

      .Case<cir::SetBitfieldOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::SetBitfieldOp op) {
        protocir::CIRSetBitfieldOp pSetBitfieldOp;
        pInst->mutable_base()->set_id(instID);

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pSetBitfieldOp.mutable_addr() = paddrID;

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pSetBitfieldOp.mutable_src() = psrcID;

        auto isVolatile = op.getIsVolatile();
        pSetBitfieldOp.set_is_volatile(isVolatile);

        pInst->mutable_set_bitfield_op()->CopyFrom(pSetBitfieldOp);
      })

      .Case<cir::ShiftOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ShiftOp op) {
        protocir::CIRShiftOp pShiftOp;
        pInst->mutable_base()->set_id(instID);

        auto value = op.getValue().getDefiningOp();
        auto valueID = internOperation(opCache, value);

        protocir::CIROpID pvalueID;
        pvalueID.set_id(valueID);

        *pShiftOp.mutable_value() = pvalueID;

        auto amount = op.getAmount().getDefiningOp();
        auto amountID = internOperation(opCache, amount);

        protocir::CIROpID pamountID;
        pamountID.set_id(amountID);

        *pShiftOp.mutable_amount() = pamountID;

        auto isShiftleft = op.getIsShiftleft();
        pShiftOp.set_is_shiftleft(isShiftleft);

        pInst->mutable_shift_op()->CopyFrom(pShiftOp);
      })

      .Case<cir::SignBitOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::SignBitOp op) {
        protocir::CIRSignBitOp pSignBitOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pSignBitOp.mutable_input() = pinputID;

        pInst->mutable_sign_bit_op()->CopyFrom(pSignBitOp);
      })

      .Case<cir::SinOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::SinOp op) {
        protocir::CIRSinOp pSinOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pSinOp.mutable_src() = psrcID;

        pInst->mutable_sin_op()->CopyFrom(pSinOp);
      })

      .Case<cir::SqrtOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::SqrtOp op) {
        protocir::CIRSqrtOp pSqrtOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pSqrtOp.mutable_src() = psrcID;

        pInst->mutable_sqrt_op()->CopyFrom(pSqrtOp);
      })

      .Case<cir::StackRestoreOp>([instID, pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::StackRestoreOp op) {
        protocir::CIRStackRestoreOp pStackRestoreOp;
        pInst->mutable_base()->set_id(instID);

        auto ptr = op.getPtr().getDefiningOp();
        auto ptrID = internOperation(opCache, ptr);

        protocir::CIROpID pptrID;
        pptrID.set_id(ptrID);

        *pStackRestoreOp.mutable_ptr() = pptrID;

        pInst->mutable_stack_restore_op()->CopyFrom(pStackRestoreOp);
      })

      .Case<cir::StackSaveOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::StackSaveOp op) {
        protocir::CIRStackSaveOp pStackSaveOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_stack_save_op()->CopyFrom(pStackSaveOp);
      })

      .Case<cir::StdFindOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::StdFindOp op) {
        protocir::CIRStdFindOp pStdFindOp;
        pInst->mutable_base()->set_id(instID);

        auto first = op.getFirst().getDefiningOp();
        auto firstID = internOperation(opCache, first);

        protocir::CIROpID pfirstID;
        pfirstID.set_id(firstID);

        *pStdFindOp.mutable_first() = pfirstID;

        auto last = op.getLast().getDefiningOp();
        auto lastID = internOperation(opCache, last);

        protocir::CIROpID plastID;
        plastID.set_id(lastID);

        *pStdFindOp.mutable_last() = plastID;

        auto pattern = op.getPattern().getDefiningOp();
        auto patternID = internOperation(opCache, pattern);

        protocir::CIROpID ppatternID;
        ppatternID.set_id(patternID);

        *pStdFindOp.mutable_pattern() = ppatternID;

        auto originalFn = op.getOriginalFn();
        *pStdFindOp.mutable_original_fn() = originalFn;

        pInst->mutable_std_find_op()->CopyFrom(pStdFindOp);
      })

      .Case<cir::StoreOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::StoreOp op) {
        protocir::CIRStoreOp pStoreOp;
        pInst->mutable_base()->set_id(instID);

        auto value = op.getValue().getDefiningOp();
        auto valueID = internOperation(opCache, value);

        protocir::CIROpID pvalueID;
        pvalueID.set_id(valueID);

        *pStoreOp.mutable_value() = pvalueID;

        auto addr = op.getAddr().getDefiningOp();
        auto addrID = internOperation(opCache, addr);

        protocir::CIROpID paddrID;
        paddrID.set_id(addrID);

        *pStoreOp.mutable_addr() = paddrID;

        auto isVolatile = op.getIsVolatile();
        pStoreOp.set_is_volatile(isVolatile);

        auto alignmentOptional = op.getAlignment();
        if (alignmentOptional) {
          auto alignment = alignmentOptional.value();
          pStoreOp.set_alignment(alignment);
        }

        pInst->mutable_store_op()->CopyFrom(pStoreOp);
      })

      .Case<cir::SwitchFlatOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::SwitchFlatOp op) {
        protocir::CIRSwitchFlatOp pSwitchFlatOp;
        pInst->mutable_base()->set_id(instID);

        auto condition = op.getCondition().getDefiningOp();
        auto conditionID = internOperation(opCache, condition);

        protocir::CIROpID pconditionID;
        pconditionID.set_id(conditionID);

        *pSwitchFlatOp.mutable_condition() = pconditionID;

        auto defaultOperands = op.getDefaultOperands();
        for (auto edefaultOperands : defaultOperands) {
          auto edefaultOperandsProto = pSwitchFlatOp.add_default_operands();
          auto edefaultOperandsID =
              internOperation(opCache, edefaultOperands.getDefiningOp());
          edefaultOperandsProto->set_id(edefaultOperandsID);
        }

        auto caseOperands = op.getCaseOperands();
        for (auto ecaseOperands : caseOperands) {
          auto ecaseOperandsProto = pSwitchFlatOp.add_case_operands();
          for (auto eecaseOperands : ecaseOperands) {
            auto eecaseOperandsProto = ecaseOperandsProto->add_range();
            auto eecaseOperandsID =
                internOperation(opCache, eecaseOperands.getDefiningOp());
            eecaseOperandsProto->set_id(eecaseOperandsID);
          }
        }

        auto caseOperandSegments = op.getCaseOperandSegments();
        for (auto ecaseOperandSegments : caseOperandSegments) {
          pSwitchFlatOp.add_case_operand_segments(ecaseOperandSegments);
        }

        pInst->mutable_switch_flat_op()->CopyFrom(pSwitchFlatOp);
      })

      .Case<cir::SwitchOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::SwitchOp op) {
        protocir::CIRSwitchOp pSwitchOp;
        pInst->mutable_base()->set_id(instID);

        auto condition = op.getCondition().getDefiningOp();
        auto conditionID = internOperation(opCache, condition);

        protocir::CIROpID pconditionID;
        pconditionID.set_id(conditionID);

        *pSwitchOp.mutable_condition() = pconditionID;

        pInst->mutable_switch_op()->CopyFrom(pSwitchOp);
      })

      .Case<cir::TernaryOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::TernaryOp op) {
        protocir::CIRTernaryOp pTernaryOp;
        pInst->mutable_base()->set_id(instID);

        auto cond = op.getCond().getDefiningOp();
        auto condID = internOperation(opCache, cond);

        protocir::CIROpID pcondID;
        pcondID.set_id(condID);

        *pTernaryOp.mutable_cond() = pcondID;

        pInst->mutable_ternary_op()->CopyFrom(pTernaryOp);
      })

      .Case<cir::ThrowOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::ThrowOp op) {
        protocir::CIRThrowOp pThrowOp;
        pInst->mutable_base()->set_id(instID);

        auto exceptionPtr = op.getExceptionPtr().getDefiningOp();
        if (exceptionPtr) {
          auto exceptionPtrID = internOperation(opCache, exceptionPtr);

          protocir::CIROpID pexceptionPtrID;
          pexceptionPtrID.set_id(exceptionPtrID);

          *pThrowOp.mutable_exception_ptr() = pexceptionPtrID;
        }

        auto typeInfoOptional = op.getTypeInfo();
        if (typeInfoOptional) {
          auto typeInfo = typeInfoOptional.value();
          *pThrowOp.mutable_type_info() = typeInfo;
        }

        auto dtorOptional = op.getDtor();
        if (dtorOptional) {
          auto dtor = dtorOptional.value();
          *pThrowOp.mutable_dtor() = dtor;
        }

        pInst->mutable_throw_op()->CopyFrom(pThrowOp);
      })

      .Case<cir::TrapOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                          &opCache](cir::TrapOp op) {
        protocir::CIRTrapOp pTrapOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_trap_op()->CopyFrom(pTrapOp);
      })

      .Case<cir::TruncOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::TruncOp op) {
        protocir::CIRTruncOp pTruncOp;
        pInst->mutable_base()->set_id(instID);

        auto src = op.getSrc().getDefiningOp();
        auto srcID = internOperation(opCache, src);

        protocir::CIROpID psrcID;
        psrcID.set_id(srcID);

        *pTruncOp.mutable_src() = psrcID;

        pInst->mutable_trunc_op()->CopyFrom(pTruncOp);
      })

      .Case<cir::TryCallOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::TryCallOp op) {
        protocir::CIRTryCallOp pTryCallOp;
        pInst->mutable_base()->set_id(instID);

        auto contOperands = op.getContOperands();
        for (auto econtOperands : contOperands) {
          auto econtOperandsProto = pTryCallOp.add_cont_operands();
          auto econtOperandsID =
              internOperation(opCache, econtOperands.getDefiningOp());
          econtOperandsProto->set_id(econtOperandsID);
        }

        auto landingPadOperands = op.getLandingPadOperands();
        for (auto elandingPadOperands : landingPadOperands) {
          auto elandingPadOperandsProto = pTryCallOp.add_landing_pad_operands();
          auto elandingPadOperandsID =
              internOperation(opCache, elandingPadOperands.getDefiningOp());
          elandingPadOperandsProto->set_id(elandingPadOperandsID);
        }

        auto argOps = op.getArgOps();
        for (auto eargOps : argOps) {
          auto eargOpsProto = pTryCallOp.add_arg_ops();
          auto eargOpsID = internOperation(opCache, eargOps.getDefiningOp());
          eargOpsProto->set_id(eargOpsID);
        }

        auto calleeOptional = op.getCallee();
        if (calleeOptional) {
          auto callee = calleeOptional.value();
          *pTryCallOp.mutable_callee() = callee;
        }

        pInst->mutable_try_call_op()->CopyFrom(pTryCallOp);
      })

      .Case<cir::TryOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                         &opCache](cir::TryOp op) {
        protocir::CIRTryOp pTryOp;
        pInst->mutable_base()->set_id(instID);

        auto synthetic = op.getSynthetic();
        pTryOp.set_synthetic(synthetic);

        auto cleanup = op.getCleanup();
        pTryOp.set_cleanup(cleanup);

        pInst->mutable_try_op()->CopyFrom(pTryOp);
      })

      .Case<cir::UnaryOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::UnaryOp op) {
        protocir::CIRUnaryOp pUnaryOp;
        pInst->mutable_base()->set_id(instID);

        auto input = op.getInput().getDefiningOp();
        auto inputID = internOperation(opCache, input);

        protocir::CIROpID pinputID;
        pinputID.set_id(inputID);

        *pUnaryOp.mutable_input() = pinputID;

        pInst->mutable_unary_op()->CopyFrom(pUnaryOp);
      })

      .Case<cir::UnreachableOp>([instID, pInst, pModuleID, &typeCache,
                                 &blockCache, &opCache](cir::UnreachableOp op) {
        protocir::CIRUnreachableOp pUnreachableOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_unreachable_op()->CopyFrom(pUnreachableOp);
      })

      .Case<cir::VAArgOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::VAArgOp op) {
        protocir::CIRVAArgOp pVAArgOp;
        pInst->mutable_base()->set_id(instID);

        auto argList = op.getArgList().getDefiningOp();
        auto argListID = internOperation(opCache, argList);

        protocir::CIROpID pargListID;
        pargListID.set_id(argListID);

        *pVAArgOp.mutable_arg_list() = pargListID;

        pInst->mutable_va_arg_op()->CopyFrom(pVAArgOp);
      })

      .Case<cir::VACopyOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::VACopyOp op) {
        protocir::CIRVACopyOp pVACopyOp;
        pInst->mutable_base()->set_id(instID);

        auto dstList = op.getDstList().getDefiningOp();
        auto dstListID = internOperation(opCache, dstList);

        protocir::CIROpID pdstListID;
        pdstListID.set_id(dstListID);

        *pVACopyOp.mutable_dst_list() = pdstListID;

        auto srcList = op.getSrcList().getDefiningOp();
        auto srcListID = internOperation(opCache, srcList);

        protocir::CIROpID psrcListID;
        psrcListID.set_id(srcListID);

        *pVACopyOp.mutable_src_list() = psrcListID;

        pInst->mutable_va_copy_op()->CopyFrom(pVACopyOp);
      })

      .Case<cir::VAEndOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::VAEndOp op) {
        protocir::CIRVAEndOp pVAEndOp;
        pInst->mutable_base()->set_id(instID);

        auto argList = op.getArgList().getDefiningOp();
        auto argListID = internOperation(opCache, argList);

        protocir::CIROpID pargListID;
        pargListID.set_id(argListID);

        *pVAEndOp.mutable_arg_list() = pargListID;

        pInst->mutable_va_end_op()->CopyFrom(pVAEndOp);
      })

      .Case<cir::VAStartOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                             &opCache](cir::VAStartOp op) {
        protocir::CIRVAStartOp pVAStartOp;
        pInst->mutable_base()->set_id(instID);

        auto argList = op.getArgList().getDefiningOp();
        auto argListID = internOperation(opCache, argList);

        protocir::CIROpID pargListID;
        pargListID.set_id(argListID);

        *pVAStartOp.mutable_arg_list() = pargListID;

        pInst->mutable_va_start_op()->CopyFrom(pVAStartOp);
      })

      .Case<cir::VTTAddrPointOp>([instID, pInst, pModuleID, &typeCache,
                                  &blockCache,
                                  &opCache](cir::VTTAddrPointOp op) {
        protocir::CIRVTTAddrPointOp pVTTAddrPointOp;
        pInst->mutable_base()->set_id(instID);

        auto symAddr = op.getSymAddr().getDefiningOp();
        if (symAddr) {
          auto symAddrID = internOperation(opCache, symAddr);

          protocir::CIROpID psymAddrID;
          psymAddrID.set_id(symAddrID);

          *pVTTAddrPointOp.mutable_sym_addr() = psymAddrID;
        }

        auto nameOptional = op.getName();
        if (nameOptional) {
          auto name = nameOptional.value();
          *pVTTAddrPointOp.mutable_name() = name;
        }

        auto offset = op.getOffset();
        pVTTAddrPointOp.set_offset(offset);

        pInst->mutable_vtt_addr_point_op()->CopyFrom(pVTTAddrPointOp);
      })

      .Case<cir::VTableAddrPointOp>([instID, pInst, pModuleID, &typeCache,
                                     &blockCache,
                                     &opCache](cir::VTableAddrPointOp op) {
        protocir::CIRVTableAddrPointOp pVTableAddrPointOp;
        pInst->mutable_base()->set_id(instID);

        auto symAddr = op.getSymAddr().getDefiningOp();
        if (symAddr) {
          auto symAddrID = internOperation(opCache, symAddr);

          protocir::CIROpID psymAddrID;
          psymAddrID.set_id(symAddrID);

          *pVTableAddrPointOp.mutable_sym_addr() = psymAddrID;
        }

        auto nameOptional = op.getName();
        if (nameOptional) {
          auto name = nameOptional.value();
          *pVTableAddrPointOp.mutable_name() = name;
        }

        auto vtableIndex = op.getVtableIndex();
        pVTableAddrPointOp.set_vtable_index(vtableIndex);

        auto addressPointIndex = op.getAddressPointIndex();
        pVTableAddrPointOp.set_address_point_index(addressPointIndex);

        pInst->mutable_v_table_addr_point_op()->CopyFrom(pVTableAddrPointOp);
      })

      .Case<cir::VecCmpOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                            &opCache](cir::VecCmpOp op) {
        protocir::CIRVecCmpOp pVecCmpOp;
        pInst->mutable_base()->set_id(instID);

        auto lhs = op.getLhs().getDefiningOp();
        auto lhsID = internOperation(opCache, lhs);

        protocir::CIROpID plhsID;
        plhsID.set_id(lhsID);

        *pVecCmpOp.mutable_lhs() = plhsID;

        auto rhs = op.getRhs().getDefiningOp();
        auto rhsID = internOperation(opCache, rhs);

        protocir::CIROpID prhsID;
        prhsID.set_id(rhsID);

        *pVecCmpOp.mutable_rhs() = prhsID;

        pInst->mutable_vec_cmp_op()->CopyFrom(pVecCmpOp);
      })

      .Case<cir::VecCreateOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::VecCreateOp op) {
        protocir::CIRVecCreateOp pVecCreateOp;
        pInst->mutable_base()->set_id(instID);

        auto elements = op.getElements();
        for (auto eelements : elements) {
          auto eelementsProto = pVecCreateOp.add_elements();
          auto eelementsID =
              internOperation(opCache, eelements.getDefiningOp());
          eelementsProto->set_id(eelementsID);
        }

        pInst->mutable_vec_create_op()->CopyFrom(pVecCreateOp);
      })

      .Case<cir::VecExtractOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecExtractOp op) {
        protocir::CIRVecExtractOp pVecExtractOp;
        pInst->mutable_base()->set_id(instID);

        auto vec = op.getVec().getDefiningOp();
        auto vecID = internOperation(opCache, vec);

        protocir::CIROpID pvecID;
        pvecID.set_id(vecID);

        *pVecExtractOp.mutable_vec() = pvecID;

        auto index = op.getIndex().getDefiningOp();
        auto indexID = internOperation(opCache, index);

        protocir::CIROpID pindexID;
        pindexID.set_id(indexID);

        *pVecExtractOp.mutable_index() = pindexID;

        pInst->mutable_vec_extract_op()->CopyFrom(pVecExtractOp);
      })

      .Case<cir::VecInsertOp>([instID, pInst, pModuleID, &typeCache,
                               &blockCache, &opCache](cir::VecInsertOp op) {
        protocir::CIRVecInsertOp pVecInsertOp;
        pInst->mutable_base()->set_id(instID);

        auto vec = op.getVec().getDefiningOp();
        auto vecID = internOperation(opCache, vec);

        protocir::CIROpID pvecID;
        pvecID.set_id(vecID);

        *pVecInsertOp.mutable_vec() = pvecID;

        auto value = op.getValue().getDefiningOp();
        auto valueID = internOperation(opCache, value);

        protocir::CIROpID pvalueID;
        pvalueID.set_id(valueID);

        *pVecInsertOp.mutable_value() = pvalueID;

        auto index = op.getIndex().getDefiningOp();
        auto indexID = internOperation(opCache, index);

        protocir::CIROpID pindexID;
        pindexID.set_id(indexID);

        *pVecInsertOp.mutable_index() = pindexID;

        pInst->mutable_vec_insert_op()->CopyFrom(pVecInsertOp);
      })

      .Case<cir::VecShuffleDynamicOp>([instID, pInst, pModuleID, &typeCache,
                                       &blockCache,
                                       &opCache](cir::VecShuffleDynamicOp op) {
        protocir::CIRVecShuffleDynamicOp pVecShuffleDynamicOp;
        pInst->mutable_base()->set_id(instID);

        auto vec = op.getVec().getDefiningOp();
        auto vecID = internOperation(opCache, vec);

        protocir::CIROpID pvecID;
        pvecID.set_id(vecID);

        *pVecShuffleDynamicOp.mutable_vec() = pvecID;

        auto indices = op.getIndices().getDefiningOp();
        auto indicesID = internOperation(opCache, indices);

        protocir::CIROpID pindicesID;
        pindicesID.set_id(indicesID);

        *pVecShuffleDynamicOp.mutable_indices() = pindicesID;

        pInst->mutable_vec_shuffle_dynamic_op()->CopyFrom(pVecShuffleDynamicOp);
      })

      .Case<cir::VecShuffleOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecShuffleOp op) {
        protocir::CIRVecShuffleOp pVecShuffleOp;
        pInst->mutable_base()->set_id(instID);

        auto vec1 = op.getVec1().getDefiningOp();
        auto vec1ID = internOperation(opCache, vec1);

        protocir::CIROpID pvec1ID;
        pvec1ID.set_id(vec1ID);

        *pVecShuffleOp.mutable_vec1() = pvec1ID;

        auto vec2 = op.getVec2().getDefiningOp();
        auto vec2ID = internOperation(opCache, vec2);

        protocir::CIROpID pvec2ID;
        pvec2ID.set_id(vec2ID);

        *pVecShuffleOp.mutable_vec2() = pvec2ID;

        pInst->mutable_vec_shuffle_op()->CopyFrom(pVecShuffleOp);
      })

      .Case<cir::VecSplatOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                              &opCache](cir::VecSplatOp op) {
        protocir::CIRVecSplatOp pVecSplatOp;
        pInst->mutable_base()->set_id(instID);

        auto value = op.getValue().getDefiningOp();
        auto valueID = internOperation(opCache, value);

        protocir::CIROpID pvalueID;
        pvalueID.set_id(valueID);

        *pVecSplatOp.mutable_value() = pvalueID;

        pInst->mutable_vec_splat_op()->CopyFrom(pVecSplatOp);
      })

      .Case<cir::VecTernaryOp>([instID, pInst, pModuleID, &typeCache,
                                &blockCache, &opCache](cir::VecTernaryOp op) {
        protocir::CIRVecTernaryOp pVecTernaryOp;
        pInst->mutable_base()->set_id(instID);

        auto cond = op.getCond().getDefiningOp();
        auto condID = internOperation(opCache, cond);

        protocir::CIROpID pcondID;
        pcondID.set_id(condID);

        *pVecTernaryOp.mutable_cond() = pcondID;

        auto vec1 = op.getVec1().getDefiningOp();
        auto vec1ID = internOperation(opCache, vec1);

        protocir::CIROpID pvec1ID;
        pvec1ID.set_id(vec1ID);

        *pVecTernaryOp.mutable_vec1() = pvec1ID;

        auto vec2 = op.getVec2().getDefiningOp();
        auto vec2ID = internOperation(opCache, vec2);

        protocir::CIROpID pvec2ID;
        pvec2ID.set_id(vec2ID);

        *pVecTernaryOp.mutable_vec2() = pvec2ID;

        pInst->mutable_vec_ternary_op()->CopyFrom(pVecTernaryOp);
      })

      .Case<cir::WhileOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::WhileOp op) {
        protocir::CIRWhileOp pWhileOp;
        pInst->mutable_base()->set_id(instID);

        pInst->mutable_while_op()->CopyFrom(pWhileOp);
      })

      .Case<cir::YieldOp>([instID, pInst, pModuleID, &typeCache, &blockCache,
                           &opCache](cir::YieldOp op) {
        protocir::CIRYieldOp pYieldOp;
        pInst->mutable_base()->set_id(instID);

        auto args = op.getArgs();
        for (auto eargs : args) {
          auto eargsProto = pYieldOp.add_args();
          auto eargsID = internOperation(opCache, eargs.getDefiningOp());
          eargsProto->set_id(eargsID);
        }

        pInst->mutable_yield_op()->CopyFrom(pYieldOp);
      })

      .Default([](mlir::Operation *op) {
        op->dump();
        llvm_unreachable("NIY");
      });
}
