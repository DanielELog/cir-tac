/* Autogenerated by mlir-tblgen; don't manually edit. */
// clang-format off

#include "cir-tac/OpDeserializer.h"
#include "cir-tac/EnumDeserializer.h"
#include "cir-tac/AttrDeserializer.h"
#include "cir-tac/Deserializer.h"

#include <llvm/ADT/TypeSwitch.h>

using namespace protocir;

mlir::Operation *OpDeserializer::deserializeMLIROp(FunctionInfo &fInfo, ModuleInfo &mInfo, MLIROp pOp) {
  switch (pOp.operation_case()) {
    case MLIROp::OperationCase::kAbsOp: {
      return deserializeCIRAbsOp(fInfo, mInfo, pOp.abs_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAllocExceptionOp: {
      return deserializeCIRAllocExceptionOp(fInfo, mInfo, pOp.alloc_exception_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAllocaOp: {
      return deserializeCIRAllocaOp(fInfo, mInfo, pOp.alloca_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kArrayCtorOp: {
      return deserializeCIRArrayCtorOp(fInfo, mInfo, pOp.array_ctor_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kArrayDtorOp: {
      return deserializeCIRArrayDtorOp(fInfo, mInfo, pOp.array_dtor_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAssumeAlignedOp: {
      return deserializeCIRAssumeAlignedOp(fInfo, mInfo, pOp.assume_aligned_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAssumeOp: {
      return deserializeCIRAssumeOp(fInfo, mInfo, pOp.assume_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAssumeSepStorageOp: {
      return deserializeCIRAssumeSepStorageOp(fInfo, mInfo, pOp.assume_sep_storage_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAtomicCmpXchgOp: {
      return deserializeCIRAtomicCmpXchgOp(fInfo, mInfo, pOp.atomic_cmp_xchg_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAtomicFetchOp: {
      return deserializeCIRAtomicFetchOp(fInfo, mInfo, pOp.atomic_fetch_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAtomicXchgOp: {
      return deserializeCIRAtomicXchgOp(fInfo, mInfo, pOp.atomic_xchg_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kAwaitOp: {
      return deserializeCIRAwaitOp(fInfo, mInfo, pOp.await_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBaseClassAddrOp: {
      return deserializeCIRBaseClassAddrOp(fInfo, mInfo, pOp.base_class_addr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBinOp: {
      return deserializeCIRBinOp(fInfo, mInfo, pOp.bin_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBinOpOverflowOp: {
      return deserializeCIRBinOpOverflowOp(fInfo, mInfo, pOp.bin_op_overflow_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitClrsbOp: {
      return deserializeCIRBitClrsbOp(fInfo, mInfo, pOp.bit_clrsb_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitClzOp: {
      return deserializeCIRBitClzOp(fInfo, mInfo, pOp.bit_clz_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitCtzOp: {
      return deserializeCIRBitCtzOp(fInfo, mInfo, pOp.bit_ctz_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitFfsOp: {
      return deserializeCIRBitFfsOp(fInfo, mInfo, pOp.bit_ffs_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitParityOp: {
      return deserializeCIRBitParityOp(fInfo, mInfo, pOp.bit_parity_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBitPopcountOp: {
      return deserializeCIRBitPopcountOp(fInfo, mInfo, pOp.bit_popcount_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBrCondOp: {
      return deserializeCIRBrCondOp(fInfo, mInfo, pOp.br_cond_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBrOp: {
      return deserializeCIRBrOp(fInfo, mInfo, pOp.br_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kBreakOp: {
      return deserializeCIRBreakOp(fInfo, mInfo, pOp.break_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kByteswapOp: {
      return deserializeCIRByteswapOp(fInfo, mInfo, pOp.byteswap_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kInlineAsmOp: {
      return deserializeCIRInlineAsmOp(fInfo, mInfo, pOp.inline_asm_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCallOp: {
      return deserializeCIRCallOp(fInfo, mInfo, pOp.call_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCaseOp: {
      return deserializeCIRCaseOp(fInfo, mInfo, pOp.case_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCastOp: {
      return deserializeCIRCastOp(fInfo, mInfo, pOp.cast_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCatchParamOp: {
      return deserializeCIRCatchParamOp(fInfo, mInfo, pOp.catch_param_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCeilOp: {
      return deserializeCIRCeilOp(fInfo, mInfo, pOp.ceil_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kClearCacheOp: {
      return deserializeCIRClearCacheOp(fInfo, mInfo, pOp.clear_cache_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCmpOp: {
      return deserializeCIRCmpOp(fInfo, mInfo, pOp.cmp_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCmpThreeWayOp: {
      return deserializeCIRCmpThreeWayOp(fInfo, mInfo, pOp.cmp_three_way_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexBinOp: {
      return deserializeCIRComplexBinOp(fInfo, mInfo, pOp.complex_bin_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexCreateOp: {
      return deserializeCIRComplexCreateOp(fInfo, mInfo, pOp.complex_create_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexImagOp: {
      return deserializeCIRComplexImagOp(fInfo, mInfo, pOp.complex_imag_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexImagPtrOp: {
      return deserializeCIRComplexImagPtrOp(fInfo, mInfo, pOp.complex_imag_ptr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexRealOp: {
      return deserializeCIRComplexRealOp(fInfo, mInfo, pOp.complex_real_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kComplexRealPtrOp: {
      return deserializeCIRComplexRealPtrOp(fInfo, mInfo, pOp.complex_real_ptr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kConditionOp: {
      return deserializeCIRConditionOp(fInfo, mInfo, pOp.condition_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kConstantOp: {
      return deserializeCIRConstantOp(fInfo, mInfo, pOp.constant_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kContinueOp: {
      return deserializeCIRContinueOp(fInfo, mInfo, pOp.continue_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCopyOp: {
      return deserializeCIRCopyOp(fInfo, mInfo, pOp.copy_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCopysignOp: {
      return deserializeCIRCopysignOp(fInfo, mInfo, pOp.copysign_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kCosOp: {
      return deserializeCIRCosOp(fInfo, mInfo, pOp.cos_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kDerivedClassAddrOp: {
      return deserializeCIRDerivedClassAddrOp(fInfo, mInfo, pOp.derived_class_addr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kDoWhileOp: {
      return deserializeCIRDoWhileOp(fInfo, mInfo, pOp.do_while_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kDynamicCastOp: {
      return deserializeCIRDynamicCastOp(fInfo, mInfo, pOp.dynamic_cast_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kEhInflightOp: {
      return deserializeCIREhInflightOp(fInfo, mInfo, pOp.eh_inflight_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kEhTypeIdOp: {
      return deserializeCIREhTypeIdOp(fInfo, mInfo, pOp.eh_type_id_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kExp2Op: {
      return deserializeCIRExp2Op(fInfo, mInfo, pOp.exp2_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kExpOp: {
      return deserializeCIRExpOp(fInfo, mInfo, pOp.exp_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kExpectOp: {
      return deserializeCIRExpectOp(fInfo, mInfo, pOp.expect_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFAbsOp: {
      return deserializeCIRFAbsOp(fInfo, mInfo, pOp.f_abs_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFMaxOp: {
      return deserializeCIRFMaxOp(fInfo, mInfo, pOp.f_max_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFMinOp: {
      return deserializeCIRFMinOp(fInfo, mInfo, pOp.f_min_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFModOp: {
      return deserializeCIRFModOp(fInfo, mInfo, pOp.f_mod_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFloorOp: {
      return deserializeCIRFloorOp(fInfo, mInfo, pOp.floor_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kForOp: {
      return deserializeCIRForOp(fInfo, mInfo, pOp.for_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFrameAddrOp: {
      return deserializeCIRFrameAddrOp(fInfo, mInfo, pOp.frame_addr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFreeExceptionOp: {
      return deserializeCIRFreeExceptionOp(fInfo, mInfo, pOp.free_exception_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kFuncOp: {
      return deserializeCIRFuncOp(fInfo, mInfo, pOp.func_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGetBitfieldOp: {
      return deserializeCIRGetBitfieldOp(fInfo, mInfo, pOp.get_bitfield_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGetGlobalOp: {
      return deserializeCIRGetGlobalOp(fInfo, mInfo, pOp.get_global_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGetMemberOp: {
      return deserializeCIRGetMemberOp(fInfo, mInfo, pOp.get_member_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGetMethodOp: {
      return deserializeCIRGetMethodOp(fInfo, mInfo, pOp.get_method_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGetRuntimeMemberOp: {
      return deserializeCIRGetRuntimeMemberOp(fInfo, mInfo, pOp.get_runtime_member_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGlobalOp: {
      return deserializeCIRGlobalOp(fInfo, mInfo, pOp.global_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kGotoOp: {
      return deserializeCIRGotoOp(fInfo, mInfo, pOp.goto_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kIfOp: {
      return deserializeCIRIfOp(fInfo, mInfo, pOp.if_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kIsConstantOp: {
      return deserializeCIRIsConstantOp(fInfo, mInfo, pOp.is_constant_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kIsFpClassOp: {
      return deserializeCIRIsFPClassOp(fInfo, mInfo, pOp.is_fp_class_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kIterBeginOp: {
      return deserializeCIRIterBeginOp(fInfo, mInfo, pOp.iter_begin_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kIterEndOp: {
      return deserializeCIRIterEndOp(fInfo, mInfo, pOp.iter_end_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLlvmIntrinsicCallOp: {
      return deserializeCIRLLVMIntrinsicCallOp(fInfo, mInfo, pOp.llvm_intrinsic_call_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLLrintOp: {
      return deserializeCIRLLrintOp(fInfo, mInfo, pOp.l_lrint_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLLroundOp: {
      return deserializeCIRLLroundOp(fInfo, mInfo, pOp.l_lround_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLabelOp: {
      return deserializeCIRLabelOp(fInfo, mInfo, pOp.label_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLoadOp: {
      return deserializeCIRLoadOp(fInfo, mInfo, pOp.load_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLog10Op: {
      return deserializeCIRLog10Op(fInfo, mInfo, pOp.log10_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLog2Op: {
      return deserializeCIRLog2Op(fInfo, mInfo, pOp.log2_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLogOp: {
      return deserializeCIRLogOp(fInfo, mInfo, pOp.log_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLrintOp: {
      return deserializeCIRLrintOp(fInfo, mInfo, pOp.lrint_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kLroundOp: {
      return deserializeCIRLroundOp(fInfo, mInfo, pOp.lround_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemChrOp: {
      return deserializeCIRMemChrOp(fInfo, mInfo, pOp.mem_chr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemCpyInlineOp: {
      return deserializeCIRMemCpyInlineOp(fInfo, mInfo, pOp.mem_cpy_inline_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemCpyOp: {
      return deserializeCIRMemCpyOp(fInfo, mInfo, pOp.mem_cpy_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemMoveOp: {
      return deserializeCIRMemMoveOp(fInfo, mInfo, pOp.mem_move_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemSetInlineOp: {
      return deserializeCIRMemSetInlineOp(fInfo, mInfo, pOp.mem_set_inline_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kMemSetOp: {
      return deserializeCIRMemSetOp(fInfo, mInfo, pOp.mem_set_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kNearbyintOp: {
      return deserializeCIRNearbyintOp(fInfo, mInfo, pOp.nearbyint_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kObjSizeOp: {
      return deserializeCIRObjSizeOp(fInfo, mInfo, pOp.obj_size_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kPowOp: {
      return deserializeCIRPowOp(fInfo, mInfo, pOp.pow_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kPrefetchOp: {
      return deserializeCIRPrefetchOp(fInfo, mInfo, pOp.prefetch_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kPtrDiffOp: {
      return deserializeCIRPtrDiffOp(fInfo, mInfo, pOp.ptr_diff_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kPtrMaskOp: {
      return deserializeCIRPtrMaskOp(fInfo, mInfo, pOp.ptr_mask_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kPtrStrideOp: {
      return deserializeCIRPtrStrideOp(fInfo, mInfo, pOp.ptr_stride_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kResumeOp: {
      return deserializeCIRResumeOp(fInfo, mInfo, pOp.resume_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kReturnAddrOp: {
      return deserializeCIRReturnAddrOp(fInfo, mInfo, pOp.return_addr_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kReturnOp: {
      return deserializeCIRReturnOp(fInfo, mInfo, pOp.return_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kRintOp: {
      return deserializeCIRRintOp(fInfo, mInfo, pOp.rint_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kRotateOp: {
      return deserializeCIRRotateOp(fInfo, mInfo, pOp.rotate_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kRoundOp: {
      return deserializeCIRRoundOp(fInfo, mInfo, pOp.round_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kScopeOp: {
      return deserializeCIRScopeOp(fInfo, mInfo, pOp.scope_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSelectOp: {
      return deserializeCIRSelectOp(fInfo, mInfo, pOp.select_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSetBitfieldOp: {
      return deserializeCIRSetBitfieldOp(fInfo, mInfo, pOp.set_bitfield_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kShiftOp: {
      return deserializeCIRShiftOp(fInfo, mInfo, pOp.shift_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSignBitOp: {
      return deserializeCIRSignBitOp(fInfo, mInfo, pOp.sign_bit_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSinOp: {
      return deserializeCIRSinOp(fInfo, mInfo, pOp.sin_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSqrtOp: {
      return deserializeCIRSqrtOp(fInfo, mInfo, pOp.sqrt_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kStackRestoreOp: {
      return deserializeCIRStackRestoreOp(fInfo, mInfo, pOp.stack_restore_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kStackSaveOp: {
      return deserializeCIRStackSaveOp(fInfo, mInfo, pOp.stack_save_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kStdFindOp: {
      return deserializeCIRStdFindOp(fInfo, mInfo, pOp.std_find_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kStdInitializerListOp: {
      return deserializeCIRStdInitializerListOp(fInfo, mInfo, pOp.std_initializer_list_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kStoreOp: {
      return deserializeCIRStoreOp(fInfo, mInfo, pOp.store_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSwitchFlatOp: {
      return deserializeCIRSwitchFlatOp(fInfo, mInfo, pOp.switch_flat_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kSwitchOp: {
      return deserializeCIRSwitchOp(fInfo, mInfo, pOp.switch_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kTernaryOp: {
      return deserializeCIRTernaryOp(fInfo, mInfo, pOp.ternary_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kThrowOp: {
      return deserializeCIRThrowOp(fInfo, mInfo, pOp.throw_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kTrapOp: {
      return deserializeCIRTrapOp(fInfo, mInfo, pOp.trap_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kTruncOp: {
      return deserializeCIRTruncOp(fInfo, mInfo, pOp.trunc_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kTryCallOp: {
      return deserializeCIRTryCallOp(fInfo, mInfo, pOp.try_call_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kTryOp: {
      return deserializeCIRTryOp(fInfo, mInfo, pOp.try_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kUnaryOp: {
      return deserializeCIRUnaryOp(fInfo, mInfo, pOp.unary_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kUnreachableOp: {
      return deserializeCIRUnreachableOp(fInfo, mInfo, pOp.unreachable_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVaArgOp: {
      return deserializeCIRVAArgOp(fInfo, mInfo, pOp.va_arg_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVaCopyOp: {
      return deserializeCIRVACopyOp(fInfo, mInfo, pOp.va_copy_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVaEndOp: {
      return deserializeCIRVAEndOp(fInfo, mInfo, pOp.va_end_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVaStartOp: {
      return deserializeCIRVAStartOp(fInfo, mInfo, pOp.va_start_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVttAddrPointOp: {
      return deserializeCIRVTTAddrPointOp(fInfo, mInfo, pOp.vtt_addr_point_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVTableAddrPointOp: {
      return deserializeCIRVTableAddrPointOp(fInfo, mInfo, pOp.v_table_addr_point_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecCmpOp: {
      return deserializeCIRVecCmpOp(fInfo, mInfo, pOp.vec_cmp_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecCreateOp: {
      return deserializeCIRVecCreateOp(fInfo, mInfo, pOp.vec_create_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecExtractOp: {
      return deserializeCIRVecExtractOp(fInfo, mInfo, pOp.vec_extract_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecInsertOp: {
      return deserializeCIRVecInsertOp(fInfo, mInfo, pOp.vec_insert_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecShuffleDynamicOp: {
      return deserializeCIRVecShuffleDynamicOp(fInfo, mInfo, pOp.vec_shuffle_dynamic_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecShuffleOp: {
      return deserializeCIRVecShuffleOp(fInfo, mInfo, pOp.vec_shuffle_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecSplatOp: {
      return deserializeCIRVecSplatOp(fInfo, mInfo, pOp.vec_splat_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kVecTernaryOp: {
      return deserializeCIRVecTernaryOp(fInfo, mInfo, pOp.vec_ternary_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kWhileOp: {
      return deserializeCIRWhileOp(fInfo, mInfo, pOp.while_op()).getOperation();
    } break;
    case MLIROp::OperationCase::kYieldOp: {
      return deserializeCIRYieldOp(fInfo, mInfo, pOp.yield_op()).getOperation();
    } break;
    default:
      llvm_unreachable("NYI");
      break;
  }
}

cir::AbsOp OpDeserializer::deserializeCIRAbsOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAbsOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());

  mlir::UnitAttr poisonDeser;
  if (pOp.has_poison()) {
    auto elem = pOp.poison();
    poisonDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::AbsOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser, poisonDeser);
}

cir::AllocExceptionOp OpDeserializer::deserializeCIRAllocExceptionOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAllocExceptionOp pOp) {
  auto addrDeser = Deserializer::getType(mInfo, pOp.addr());
  auto sizeDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.size());
  return mInfo.builder.create<cir::AllocExceptionOp>(mInfo.builder.getUnknownLoc(), addrDeser, sizeDeser);
}

cir::AllocaOp OpDeserializer::deserializeCIRAllocaOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAllocaOp pOp) {
  auto addrDeser = Deserializer::getType(mInfo, pOp.addr());

  mlir::Value dynAllocSizeDeser;
  if (pOp.has_dyn_alloc_size()) {
    auto elem = pOp.dyn_alloc_size();
    dynAllocSizeDeser = Deserializer::deserializeValue(fInfo, elem);
  }
  auto alloca_typeDeser = AttrDeserializer::deserializeMLIRTypeAttr(mInfo, pOp.alloca_type());
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.name());

  mlir::UnitAttr initDeser;
  if (pOp.has_init()) {
    auto elem = pOp.init();
    initDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr constantDeser;
  if (pOp.has_constant()) {
    auto elem = pOp.constant();
    constantDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::IntegerAttr alignmentDeser;
  if (pOp.has_alignment()) {
    auto elem = pOp.alignment();
    alignmentDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, elem);
  }

  mlir::ArrayAttr annotationsDeser;
  if (pOp.has_annotations()) {
    auto elem = pOp.annotations();
    annotationsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  cir::ASTVarDeclInterface astDeser;
  return mInfo.builder.create<cir::AllocaOp>(mInfo.builder.getUnknownLoc(), addrDeser, dynAllocSizeDeser, alloca_typeDeser, nameDeser, initDeser, constantDeser, alignmentDeser, annotationsDeser, astDeser);
}

cir::ArrayCtor OpDeserializer::deserializeCIRArrayCtorOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRArrayCtorOp pOp) {
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  return mInfo.builder.create<cir::ArrayCtor>(mInfo.builder.getUnknownLoc(), addrDeser);
}

cir::ArrayDtor OpDeserializer::deserializeCIRArrayDtorOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRArrayDtorOp pOp) {
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  return mInfo.builder.create<cir::ArrayDtor>(mInfo.builder.getUnknownLoc(), addrDeser);
}

cir::AssumeAlignedOp OpDeserializer::deserializeCIRAssumeAlignedOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAssumeAlignedOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto pointerDeser = Deserializer::deserializeValue(fInfo, pOp.pointer());
  auto alignmentDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.alignment());

  mlir::Value offsetDeser;
  if (pOp.has_offset()) {
    auto elem = pOp.offset();
    offsetDeser = Deserializer::deserializeValue(fInfo, elem);
  }
  return mInfo.builder.create<cir::AssumeAlignedOp>(mInfo.builder.getUnknownLoc(), resultDeser, pointerDeser, alignmentDeser, offsetDeser);
}

cir::AssumeOp OpDeserializer::deserializeCIRAssumeOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAssumeOp pOp) {
  auto predicateDeser = Deserializer::deserializeValue(fInfo, pOp.predicate());
  return mInfo.builder.create<cir::AssumeOp>(mInfo.builder.getUnknownLoc(), predicateDeser);
}

cir::AssumeSepStorageOp OpDeserializer::deserializeCIRAssumeSepStorageOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAssumeSepStorageOp pOp) {
  auto ptr1Deser = Deserializer::deserializeValue(fInfo, pOp.ptr1());
  auto ptr2Deser = Deserializer::deserializeValue(fInfo, pOp.ptr2());
  return mInfo.builder.create<cir::AssumeSepStorageOp>(mInfo.builder.getUnknownLoc(), ptr1Deser, ptr2Deser);
}

cir::AtomicCmpXchg OpDeserializer::deserializeCIRAtomicCmpXchgOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAtomicCmpXchgOp pOp) {
  auto oldDeser = Deserializer::getType(mInfo, pOp.old());
  auto cmpDeser = Deserializer::getType(mInfo, pOp.cmp());
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  auto expectedDeser = Deserializer::deserializeValue(fInfo, pOp.expected());
  auto desiredDeser = Deserializer::deserializeValue(fInfo, pOp.desired());
  auto succ_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(pOp.succ_order()));
  auto fail_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(pOp.fail_order()));

  mlir::UnitAttr weakDeser;
  if (pOp.has_weak()) {
    auto elem = pOp.weak();
    weakDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::AtomicCmpXchg>(mInfo.builder.getUnknownLoc(), oldDeser, cmpDeser, ptrDeser, expectedDeser, desiredDeser, succ_orderDeser, fail_orderDeser, weakDeser, is_volatileDeser);
}

cir::AtomicFetch OpDeserializer::deserializeCIRAtomicFetchOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAtomicFetchOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  auto binopDeser = cir::AtomicFetchKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRAtomicFetchKind(pOp.binop()));
  auto mem_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(pOp.mem_order()));

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr fetch_firstDeser;
  if (pOp.has_fetch_first()) {
    auto elem = pOp.fetch_first();
    fetch_firstDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::AtomicFetch>(mInfo.builder.getUnknownLoc(), resultDeser, ptrDeser, valDeser, binopDeser, mem_orderDeser, is_volatileDeser, fetch_firstDeser);
}

cir::AtomicXchg OpDeserializer::deserializeCIRAtomicXchgOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAtomicXchgOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  auto mem_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(pOp.mem_order()));

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::AtomicXchg>(mInfo.builder.getUnknownLoc(), resultDeser, ptrDeser, valDeser, mem_orderDeser, is_volatileDeser);
}

cir::AwaitOp OpDeserializer::deserializeCIRAwaitOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRAwaitOp pOp) {
  auto kindDeser = cir::AwaitKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRAwaitKind(pOp.kind()));
  return mInfo.builder.create<cir::AwaitOp>(mInfo.builder.getUnknownLoc(), kindDeser);
}

cir::BaseClassAddrOp OpDeserializer::deserializeCIRBaseClassAddrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBaseClassAddrOp pOp) {
  auto base_addrDeser = Deserializer::getType(mInfo, pOp.base_addr());
  auto derived_addrDeser = Deserializer::deserializeValue(fInfo, pOp.derived_addr());
  auto offsetDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.offset());

  mlir::UnitAttr assume_not_nullDeser;
  if (pOp.has_assume_not_null()) {
    auto elem = pOp.assume_not_null();
    assume_not_nullDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::BaseClassAddrOp>(mInfo.builder.getUnknownLoc(), base_addrDeser, derived_addrDeser, offsetDeser, assume_not_nullDeser);
}

cir::BinOp OpDeserializer::deserializeCIRBinOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBinOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::BinOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRBinOpKind(pOp.kind()));
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());

  mlir::UnitAttr no_unsigned_wrapDeser;
  if (pOp.has_no_unsigned_wrap()) {
    auto elem = pOp.no_unsigned_wrap();
    no_unsigned_wrapDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr no_signed_wrapDeser;
  if (pOp.has_no_signed_wrap()) {
    auto elem = pOp.no_signed_wrap();
    no_signed_wrapDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::BinOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, lhsDeser, rhsDeser, no_unsigned_wrapDeser, no_signed_wrapDeser);
}

cir::BinOpOverflowOp OpDeserializer::deserializeCIRBinOpOverflowOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBinOpOverflowOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto overflowDeser = Deserializer::getType(mInfo, pOp.overflow());
  auto kindDeser = cir::BinOpOverflowKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRBinOpOverflowKind(pOp.kind()));
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::BinOpOverflowOp>(mInfo.builder.getUnknownLoc(), resultDeser, overflowDeser, kindDeser, lhsDeser, rhsDeser);
}

cir::BitClrsbOp OpDeserializer::deserializeCIRBitClrsbOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitClrsbOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitClrsbOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BitClzOp OpDeserializer::deserializeCIRBitClzOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitClzOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitClzOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BitCtzOp OpDeserializer::deserializeCIRBitCtzOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitCtzOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitCtzOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BitFfsOp OpDeserializer::deserializeCIRBitFfsOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitFfsOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitFfsOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BitParityOp OpDeserializer::deserializeCIRBitParityOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitParityOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitParityOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BitPopcountOp OpDeserializer::deserializeCIRBitPopcountOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBitPopcountOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::BitPopcountOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::BrCondOp OpDeserializer::deserializeCIRBrCondOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBrCondOp pOp) {
  auto condDeser = Deserializer::deserializeValue(fInfo, pOp.cond());

  std::vector<mlir::Value> destOperandsTrueDeser;
  for (auto i = 0; i < pOp.dest_operands_true_size(); i++) {
    auto elem = pOp.dest_operands_true(i);
    destOperandsTrueDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }

  std::vector<mlir::Value> destOperandsFalseDeser;
  for (auto i = 0; i < pOp.dest_operands_false_size(); i++) {
    auto elem = pOp.dest_operands_false(i);
    destOperandsFalseDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  auto destTrueDeser = Deserializer::getBlock(fInfo, pOp.dest_true());
  auto destFalseDeser = Deserializer::getBlock(fInfo, pOp.dest_false());
  return mInfo.builder.create<cir::BrCondOp>(mInfo.builder.getUnknownLoc(), condDeser, destOperandsTrueDeser, destOperandsFalseDeser, destTrueDeser, destFalseDeser);
}

cir::BrOp OpDeserializer::deserializeCIRBrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBrOp pOp) {
  std::vector<mlir::Value> destOperandsDeser;
  for (auto i = 0; i < pOp.dest_operands_size(); i++) {
    auto elem = pOp.dest_operands(i);
    destOperandsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  auto destDeser = Deserializer::getBlock(fInfo, pOp.dest());
  return mInfo.builder.create<cir::BrOp>(mInfo.builder.getUnknownLoc(), destOperandsDeser, destDeser);
}

cir::BreakOp OpDeserializer::deserializeCIRBreakOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRBreakOp pOp) {
  return mInfo.builder.create<cir::BreakOp>(mInfo.builder.getUnknownLoc());
}

cir::ByteswapOp OpDeserializer::deserializeCIRByteswapOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRByteswapOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::ByteswapOp>(mInfo.builder.getUnknownLoc(), resultDeser, inputDeser);
}

cir::InlineAsmOp OpDeserializer::deserializeCIRInlineAsmOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRInlineAsmOp pOp) {
  mlir::Type resDeser;
  if (pOp.has_res()) {
    auto elem = pOp.res();
    resDeser = Deserializer::getType(mInfo, elem);
  }

  std::vector<mlir::ValueRange> operandsDeser;
  for (auto j = 0; j < pOp.operands_size(); j++) {std::vector<mlir::Value> pOpInner;
    for (auto i = 0; i < pOp.operands(j).list_size(); i++) {
      auto elem = pOp.operands(j).list(i);
      pOpInner.push_back(Deserializer::deserializeValue(fInfo, elem));
    }

    operandsDeser.push_back(pOpInner);
  }
  auto asm_stringDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.asm_string());
  auto constraintsDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.constraints());

  mlir::UnitAttr side_effectsDeser;
  if (pOp.has_side_effects()) {
    auto elem = pOp.side_effects();
    side_effectsDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  auto asm_flavorDeser = cir::AsmFlavorAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRAsmFlavor(pOp.asm_flavor()));
  auto operand_attrsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pOp.operand_attrs());
  return mInfo.builder.create<cir::InlineAsmOp>(mInfo.builder.getUnknownLoc(), resDeser, operandsDeser, asm_stringDeser, constraintsDeser, side_effectsDeser, asm_flavorDeser, operand_attrsDeser);
}

cir::CallOp OpDeserializer::deserializeCIRCallOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCallOp pOp) {
  mlir::Type resultDeser;
  if (pOp.has_result()) {
    auto elem = pOp.result();
    resultDeser = Deserializer::getType(mInfo, elem);
  }

  mlir::UnitAttr exceptionDeser;
  if (pOp.has_exception()) {
    auto elem = pOp.exception();
    exceptionDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::FlatSymbolRefAttr calleeDeser;
  if (pOp.has_callee()) {
    auto elem = pOp.callee();
    calleeDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  std::vector<mlir::Value> arg_opsDeser;
  for (auto i = 0; i < pOp.arg_ops_size(); i++) {
    auto elem = pOp.arg_ops(i);
    arg_opsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  auto calling_convDeser = cir::CallingConvAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCallingConv(pOp.calling_conv()));
  auto extra_attrsDeser = AttrDeserializer::deserializeCIRExtraFuncAttributesAttr(mInfo, pOp.extra_attrs());
  cir::ASTCallExprInterface astDeser;
  return mInfo.builder.create<cir::CallOp>(mInfo.builder.getUnknownLoc(), resultDeser, exceptionDeser, calleeDeser, arg_opsDeser, calling_convDeser, extra_attrsDeser, astDeser);
}

cir::CaseOp OpDeserializer::deserializeCIRCaseOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCaseOp pOp) {
  auto valueDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pOp.value());
  auto kindDeser = cir::CaseOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCaseOpKind(pOp.kind()));
  return mInfo.builder.create<cir::CaseOp>(mInfo.builder.getUnknownLoc(), valueDeser, kindDeser);
}

cir::CastOp OpDeserializer::deserializeCIRCastOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCastOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::CastKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCastKind(pOp.kind()));
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::CastOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, srcDeser);
}

cir::CatchParamOp OpDeserializer::deserializeCIRCatchParamOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCatchParamOp pOp) {
  mlir::Type paramDeser;
  if (pOp.has_param()) {
    auto elem = pOp.param();
    paramDeser = Deserializer::getType(mInfo, elem);
  }

  mlir::Value exception_ptrDeser;
  if (pOp.has_exception_ptr()) {
    auto elem = pOp.exception_ptr();
    exception_ptrDeser = Deserializer::deserializeValue(fInfo, elem);
  }

  cir::CatchParamKindAttr kindDeser;
  if (pOp.has_kind()) {
    auto elem = pOp.kind();
    kindDeser = cir::CatchParamKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCatchParamKind(elem));
  }
  return mInfo.builder.create<cir::CatchParamOp>(mInfo.builder.getUnknownLoc(), paramDeser, exception_ptrDeser, kindDeser);
}

cir::CeilOp OpDeserializer::deserializeCIRCeilOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCeilOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::CeilOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ClearCacheOp OpDeserializer::deserializeCIRClearCacheOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRClearCacheOp pOp) {
  auto beginDeser = Deserializer::deserializeValue(fInfo, pOp.begin());
  auto endDeser = Deserializer::deserializeValue(fInfo, pOp.end());
  return mInfo.builder.create<cir::ClearCacheOp>(mInfo.builder.getUnknownLoc(), beginDeser, endDeser);
}

cir::CmpOp OpDeserializer::deserializeCIRCmpOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCmpOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::CmpOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCmpOpKind(pOp.kind()));
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::CmpOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, lhsDeser, rhsDeser);
}

cir::CmpThreeWayOp OpDeserializer::deserializeCIRCmpThreeWayOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCmpThreeWayOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  auto infoDeser = AttrDeserializer::deserializeCIRCmpThreeWayInfoAttr(mInfo, pOp.info());
  return mInfo.builder.create<cir::CmpThreeWayOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser, infoDeser);
}

cir::ComplexBinOp OpDeserializer::deserializeCIRComplexBinOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexBinOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::ComplexBinOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRComplexBinOpKind(pOp.kind()));
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  auto rangeDeser = cir::ComplexRangeKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRComplexRangeKind(pOp.range()));

  mlir::UnitAttr promotedDeser;
  if (pOp.has_promoted()) {
    auto elem = pOp.promoted();
    promotedDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ComplexBinOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, lhsDeser, rhsDeser, rangeDeser, promotedDeser);
}

cir::ComplexCreateOp OpDeserializer::deserializeCIRComplexCreateOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexCreateOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto realDeser = Deserializer::deserializeValue(fInfo, pOp.real());
  auto imagDeser = Deserializer::deserializeValue(fInfo, pOp.imag());
  return mInfo.builder.create<cir::ComplexCreateOp>(mInfo.builder.getUnknownLoc(), resultDeser, mlir::cast<mlir::Value>(realDeser), mlir::cast<mlir::Value>(imagDeser));
}

cir::ComplexImagOp OpDeserializer::deserializeCIRComplexImagOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexImagOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto operandDeser = Deserializer::deserializeValue(fInfo, pOp.operand());
  return mInfo.builder.create<cir::ComplexImagOp>(mInfo.builder.getUnknownLoc(), resultDeser, operandDeser);
}

cir::ComplexImagPtrOp OpDeserializer::deserializeCIRComplexImagPtrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexImagPtrOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto operandDeser = Deserializer::deserializeValue(fInfo, pOp.operand());
  return mInfo.builder.create<cir::ComplexImagPtrOp>(mInfo.builder.getUnknownLoc(), resultDeser, operandDeser);
}

cir::ComplexRealOp OpDeserializer::deserializeCIRComplexRealOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexRealOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto operandDeser = Deserializer::deserializeValue(fInfo, pOp.operand());
  return mInfo.builder.create<cir::ComplexRealOp>(mInfo.builder.getUnknownLoc(), resultDeser, operandDeser);
}

cir::ComplexRealPtrOp OpDeserializer::deserializeCIRComplexRealPtrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRComplexRealPtrOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto operandDeser = Deserializer::deserializeValue(fInfo, pOp.operand());
  return mInfo.builder.create<cir::ComplexRealPtrOp>(mInfo.builder.getUnknownLoc(), resultDeser, operandDeser);
}

cir::ConditionOp OpDeserializer::deserializeCIRConditionOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRConditionOp pOp) {
  auto conditionDeser = Deserializer::deserializeValue(fInfo, pOp.condition());
  return mInfo.builder.create<cir::ConditionOp>(mInfo.builder.getUnknownLoc(), conditionDeser);
}

cir::ConstantOp OpDeserializer::deserializeCIRConstantOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRConstantOp pOp) {
  auto resDeser = Deserializer::getType(mInfo, pOp.res());
  auto valueDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, pOp.value());
  return mInfo.builder.create<cir::ConstantOp>(mInfo.builder.getUnknownLoc(), resDeser, mlir::cast<mlir::TypedAttr>(valueDeser));
}

cir::ContinueOp OpDeserializer::deserializeCIRContinueOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRContinueOp pOp) {
  return mInfo.builder.create<cir::ContinueOp>(mInfo.builder.getUnknownLoc());
}

cir::CopyOp OpDeserializer::deserializeCIRCopyOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCopyOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::ArrayAttr tbaaDeser;
  if (pOp.has_tbaa()) {
    auto elem = pOp.tbaa();
    tbaaDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::CopyOp>(mInfo.builder.getUnknownLoc(), dstDeser, srcDeser, is_volatileDeser, tbaaDeser);
}

cir::CopysignOp OpDeserializer::deserializeCIRCopysignOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCopysignOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::CopysignOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::CosOp OpDeserializer::deserializeCIRCosOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRCosOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::CosOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::DerivedClassAddrOp OpDeserializer::deserializeCIRDerivedClassAddrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRDerivedClassAddrOp pOp) {
  auto derived_addrDeser = Deserializer::getType(mInfo, pOp.derived_addr());
  auto base_addrDeser = Deserializer::deserializeValue(fInfo, pOp.base_addr());
  auto offsetDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.offset());

  mlir::UnitAttr assume_not_nullDeser;
  if (pOp.has_assume_not_null()) {
    auto elem = pOp.assume_not_null();
    assume_not_nullDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::DerivedClassAddrOp>(mInfo.builder.getUnknownLoc(), derived_addrDeser, base_addrDeser, offsetDeser, assume_not_nullDeser);
}

cir::DoWhileOp OpDeserializer::deserializeCIRDoWhileOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRDoWhileOp pOp) {
  return mInfo.builder.create<cir::DoWhileOp>(mInfo.builder.getUnknownLoc());
}

cir::DynamicCastOp OpDeserializer::deserializeCIRDynamicCastOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRDynamicCastOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::DynamicCastKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRDynamicCastKind(pOp.kind()));
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());

  cir::DynamicCastInfoAttr infoDeser;
  if (pOp.has_info()) {
    auto elem = pOp.info();
    infoDeser = AttrDeserializer::deserializeCIRDynamicCastInfoAttr(mInfo, elem);
  }

  mlir::UnitAttr relative_layoutDeser;
  if (pOp.has_relative_layout()) {
    auto elem = pOp.relative_layout();
    relative_layoutDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::DynamicCastOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, srcDeser, infoDeser, relative_layoutDeser);
}

cir::EhInflightOp OpDeserializer::deserializeCIREhInflightOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIREhInflightOp pOp) {
  auto exception_ptrDeser = Deserializer::getType(mInfo, pOp.exception_ptr());
  auto type_idDeser = Deserializer::getType(mInfo, pOp.type_id());

  mlir::UnitAttr cleanupDeser;
  if (pOp.has_cleanup()) {
    auto elem = pOp.cleanup();
    cleanupDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::ArrayAttr sym_type_listDeser;
  if (pOp.has_sym_type_list()) {
    auto elem = pOp.sym_type_list();
    sym_type_listDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::EhInflightOp>(mInfo.builder.getUnknownLoc(), exception_ptrDeser, type_idDeser, cleanupDeser, sym_type_listDeser);
}

cir::EhTypeIdOp OpDeserializer::deserializeCIREhTypeIdOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIREhTypeIdOp pOp) {
  auto type_idDeser = Deserializer::getType(mInfo, pOp.type_id());
  auto type_symDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pOp.type_sym());
  return mInfo.builder.create<cir::EhTypeIdOp>(mInfo.builder.getUnknownLoc(), type_idDeser, type_symDeser);
}

cir::Exp2Op OpDeserializer::deserializeCIRExp2Op(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRExp2Op pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::Exp2Op>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ExpOp OpDeserializer::deserializeCIRExpOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRExpOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::ExpOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ExpectOp OpDeserializer::deserializeCIRExpectOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRExpectOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  auto expectedDeser = Deserializer::deserializeValue(fInfo, pOp.expected());

  mlir::FloatAttr probDeser;
  if (pOp.has_prob()) {
    auto elem = pOp.prob();
    probDeser = AttrDeserializer::deserializeMLIRFloatAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ExpectOp>(mInfo.builder.getUnknownLoc(), resultDeser, valDeser, expectedDeser, probDeser);
}

cir::FAbsOp OpDeserializer::deserializeCIRFAbsOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFAbsOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::FAbsOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::FMaxOp OpDeserializer::deserializeCIRFMaxOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFMaxOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::FMaxOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::FMinOp OpDeserializer::deserializeCIRFMinOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFMinOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::FMinOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::FModOp OpDeserializer::deserializeCIRFModOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFModOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::FModOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::FloorOp OpDeserializer::deserializeCIRFloorOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFloorOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::FloorOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ForOp OpDeserializer::deserializeCIRForOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRForOp pOp) {
  return mInfo.builder.create<cir::ForOp>(mInfo.builder.getUnknownLoc());
}

cir::FrameAddrOp OpDeserializer::deserializeCIRFrameAddrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFrameAddrOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto levelDeser = Deserializer::deserializeValue(fInfo, pOp.level());
  return mInfo.builder.create<cir::FrameAddrOp>(mInfo.builder.getUnknownLoc(), resultDeser, levelDeser);
}

cir::FreeExceptionOp OpDeserializer::deserializeCIRFreeExceptionOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFreeExceptionOp pOp) {
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  return mInfo.builder.create<cir::FreeExceptionOp>(mInfo.builder.getUnknownLoc(), ptrDeser);
}

cir::FuncOp OpDeserializer::deserializeCIRFuncOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRFuncOp pOp) {
  auto sym_nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.sym_name());
  auto global_visibilityDeser = AttrDeserializer::deserializeCIRVisibilityAttr(mInfo, pOp.global_visibility());
  auto function_typeDeser = AttrDeserializer::deserializeMLIRTypeAttr(mInfo, pOp.function_type());

  mlir::UnitAttr builtinDeser;
  if (pOp.has_builtin()) {
    auto elem = pOp.builtin();
    builtinDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr coroutineDeser;
  if (pOp.has_coroutine()) {
    auto elem = pOp.coroutine();
    coroutineDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr lambdaDeser;
  if (pOp.has_lambda()) {
    auto elem = pOp.lambda();
    lambdaDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr no_protoDeser;
  if (pOp.has_no_proto()) {
    auto elem = pOp.no_proto();
    no_protoDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr dsolocalDeser;
  if (pOp.has_dsolocal()) {
    auto elem = pOp.dsolocal();
    dsolocalDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  auto linkageDeser = cir::GlobalLinkageKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRGlobalLinkageKind(pOp.linkage()));
  auto calling_convDeser = cir::CallingConvAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCallingConv(pOp.calling_conv()));
  auto extra_attrsDeser = AttrDeserializer::deserializeCIRExtraFuncAttributesAttr(mInfo, pOp.extra_attrs());

  mlir::StringAttr sym_visibilityDeser;
  if (pOp.has_sym_visibility()) {
    auto elem = pOp.sym_visibility();
    sym_visibilityDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, elem);
  }

  mlir::UnitAttr comdatDeser;
  if (pOp.has_comdat()) {
    auto elem = pOp.comdat();
    comdatDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::ArrayAttr arg_attrsDeser;
  if (pOp.has_arg_attrs()) {
    auto elem = pOp.arg_attrs();
    arg_attrsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }

  mlir::ArrayAttr res_attrsDeser;
  if (pOp.has_res_attrs()) {
    auto elem = pOp.res_attrs();
    res_attrsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }

  mlir::FlatSymbolRefAttr aliaseeDeser;
  if (pOp.has_aliasee()) {
    auto elem = pOp.aliasee();
    aliaseeDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  cir::GlobalCtorAttr global_ctorDeser;
  if (pOp.has_global_ctor()) {
    auto elem = pOp.global_ctor();
    global_ctorDeser = AttrDeserializer::deserializeCIRGlobalCtorAttr(mInfo, elem);
  }

  cir::GlobalDtorAttr global_dtorDeser;
  if (pOp.has_global_dtor()) {
    auto elem = pOp.global_dtor();
    global_dtorDeser = AttrDeserializer::deserializeCIRGlobalDtorAttr(mInfo, elem);
  }

  mlir::ArrayAttr annotationsDeser;
  if (pOp.has_annotations()) {
    auto elem = pOp.annotations();
    annotationsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }

  mlir::Attribute astDeser;
  if (pOp.has_ast()) {
    auto elem = pOp.ast();
    astDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, elem);
  }
  return mInfo.builder.create<cir::FuncOp>(mInfo.builder.getUnknownLoc(), sym_nameDeser, global_visibilityDeser, function_typeDeser, builtinDeser, coroutineDeser, lambdaDeser, no_protoDeser, dsolocalDeser, linkageDeser, calling_convDeser, extra_attrsDeser, sym_visibilityDeser, comdatDeser, arg_attrsDeser, res_attrsDeser, aliaseeDeser, global_ctorDeser, global_dtorDeser, annotationsDeser, astDeser);
}

cir::GetBitfieldOp OpDeserializer::deserializeCIRGetBitfieldOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGetBitfieldOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  auto bitfield_infoDeser = AttrDeserializer::deserializeCIRBitfieldInfoAttr(mInfo, pOp.bitfield_info());

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::GetBitfieldOp>(mInfo.builder.getUnknownLoc(), resultDeser, addrDeser, bitfield_infoDeser, is_volatileDeser);
}

cir::GetGlobalOp OpDeserializer::deserializeCIRGetGlobalOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGetGlobalOp pOp) {
  auto addrDeser = Deserializer::getType(mInfo, pOp.addr());
  auto nameDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pOp.name());

  mlir::UnitAttr tlsDeser;
  if (pOp.has_tls()) {
    auto elem = pOp.tls();
    tlsDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::GetGlobalOp>(mInfo.builder.getUnknownLoc(), addrDeser, nameDeser, tlsDeser);
}

cir::GetMemberOp OpDeserializer::deserializeCIRGetMemberOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGetMemberOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  auto nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.name());
  auto index_attrDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.index_attr());
  return mInfo.builder.create<cir::GetMemberOp>(mInfo.builder.getUnknownLoc(), resultDeser, addrDeser, nameDeser, index_attrDeser);
}

cir::GetMethodOp OpDeserializer::deserializeCIRGetMethodOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGetMethodOp pOp) {
  auto calleeDeser = Deserializer::getType(mInfo, pOp.callee());
  auto adjusted_thisDeser = Deserializer::getType(mInfo, pOp.adjusted_this());
  auto methodDeser = Deserializer::deserializeValue(fInfo, pOp.method());
  auto objectDeser = Deserializer::deserializeValue(fInfo, pOp.object());
  return mInfo.builder.create<cir::GetMethodOp>(mInfo.builder.getUnknownLoc(), calleeDeser, adjusted_thisDeser, methodDeser, objectDeser);
}

cir::GetRuntimeMemberOp OpDeserializer::deserializeCIRGetRuntimeMemberOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGetRuntimeMemberOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  auto memberDeser = Deserializer::deserializeValue(fInfo, pOp.member());
  return mInfo.builder.create<cir::GetRuntimeMemberOp>(mInfo.builder.getUnknownLoc(), resultDeser, addrDeser, memberDeser);
}

cir::GlobalOp OpDeserializer::deserializeCIRGlobalOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGlobalOp pOp) {
  auto sym_nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.sym_name());
  auto global_visibilityDeser = AttrDeserializer::deserializeCIRVisibilityAttr(mInfo, pOp.global_visibility());

  mlir::StringAttr sym_visibilityDeser;
  if (pOp.has_sym_visibility()) {
    auto elem = pOp.sym_visibility();
    sym_visibilityDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, elem);
  }
  auto sym_typeDeser = AttrDeserializer::deserializeMLIRTypeAttr(mInfo, pOp.sym_type());
  auto linkageDeser = cir::GlobalLinkageKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRGlobalLinkageKind(pOp.linkage()));

  cir::AddressSpaceAttr addr_spaceDeser;
  if (pOp.has_addr_space()) {
    auto elem = pOp.addr_space();
    addr_spaceDeser = AttrDeserializer::deserializeCIRAddressSpaceAttr(mInfo, elem);
  }

  cir::TLS_ModelAttr tls_modelDeser;
  if (pOp.has_tls_model()) {
    auto elem = pOp.tls_model();
    tls_modelDeser = cir::TLS_ModelAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRTLSModel(elem));
  }

  mlir::Attribute initial_valueDeser;
  if (pOp.has_initial_value()) {
    auto elem = pOp.initial_value();
    initial_valueDeser = AttrDeserializer::deserializeMLIRAttribute(mInfo, elem);
  }

  mlir::UnitAttr comdatDeser;
  if (pOp.has_comdat()) {
    auto elem = pOp.comdat();
    comdatDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr constantDeser;
  if (pOp.has_constant()) {
    auto elem = pOp.constant();
    constantDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr dsolocalDeser;
  if (pOp.has_dsolocal()) {
    auto elem = pOp.dsolocal();
    dsolocalDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::IntegerAttr alignmentDeser;
  if (pOp.has_alignment()) {
    auto elem = pOp.alignment();
    alignmentDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, elem);
  }
  cir::ASTVarDeclInterface astDeser;

  mlir::StringAttr sectionDeser;
  if (pOp.has_section()) {
    auto elem = pOp.section();
    sectionDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, elem);
  }

  mlir::ArrayAttr annotationsDeser;
  if (pOp.has_annotations()) {
    auto elem = pOp.annotations();
    annotationsDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::GlobalOp>(mInfo.builder.getUnknownLoc(), sym_nameDeser, global_visibilityDeser, sym_visibilityDeser, sym_typeDeser, linkageDeser, addr_spaceDeser, tls_modelDeser, initial_valueDeser, comdatDeser, constantDeser, dsolocalDeser, alignmentDeser, astDeser, sectionDeser, annotationsDeser);
}

cir::GotoOp OpDeserializer::deserializeCIRGotoOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRGotoOp pOp) {
  auto labelDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.label());
  return mInfo.builder.create<cir::GotoOp>(mInfo.builder.getUnknownLoc(), labelDeser);
}

cir::IfOp OpDeserializer::deserializeCIRIfOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRIfOp pOp) {
  auto conditionDeser = Deserializer::deserializeValue(fInfo, pOp.condition());
  return mInfo.builder.create<cir::IfOp>(mInfo.builder.getUnknownLoc(), conditionDeser);
}

cir::IsConstantOp OpDeserializer::deserializeCIRIsConstantOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRIsConstantOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  return mInfo.builder.create<cir::IsConstantOp>(mInfo.builder.getUnknownLoc(), resultDeser, valDeser);
}

cir::IsFPClassOp OpDeserializer::deserializeCIRIsFPClassOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRIsFPClassOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto flagsDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.flags());
  return mInfo.builder.create<cir::IsFPClassOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser, flagsDeser);
}

cir::IterBeginOp OpDeserializer::deserializeCIRIterBeginOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRIterBeginOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto original_fnDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pOp.original_fn());
  auto containerDeser = Deserializer::deserializeValue(fInfo, pOp.container());
  return mInfo.builder.create<cir::IterBeginOp>(mInfo.builder.getUnknownLoc(), resultDeser, original_fnDeser, containerDeser);
}

cir::IterEndOp OpDeserializer::deserializeCIRIterEndOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRIterEndOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto original_fnDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pOp.original_fn());
  auto containerDeser = Deserializer::deserializeValue(fInfo, pOp.container());
  return mInfo.builder.create<cir::IterEndOp>(mInfo.builder.getUnknownLoc(), resultDeser, original_fnDeser, containerDeser);
}

cir::LLVMIntrinsicCallOp OpDeserializer::deserializeCIRLLVMIntrinsicCallOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLLVMIntrinsicCallOp pOp) {
  mlir::Type resultDeser;
  if (pOp.has_result()) {
    auto elem = pOp.result();
    resultDeser = Deserializer::getType(mInfo, elem);
  }
  auto intrinsic_nameDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.intrinsic_name());

  std::vector<mlir::Value> arg_opsDeser;
  for (auto i = 0; i < pOp.arg_ops_size(); i++) {
    auto elem = pOp.arg_ops(i);
    arg_opsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  return mInfo.builder.create<cir::LLVMIntrinsicCallOp>(mInfo.builder.getUnknownLoc(), resultDeser, intrinsic_nameDeser, arg_opsDeser);
}

cir::LLrintOp OpDeserializer::deserializeCIRLLrintOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLLrintOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::LLrintOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::LLroundOp OpDeserializer::deserializeCIRLLroundOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLLroundOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::LLroundOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::LabelOp OpDeserializer::deserializeCIRLabelOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLabelOp pOp) {
  auto labelDeser = AttrDeserializer::deserializeMLIRStringAttr(mInfo, pOp.label());
  return mInfo.builder.create<cir::LabelOp>(mInfo.builder.getUnknownLoc(), labelDeser);
}

cir::LoadOp OpDeserializer::deserializeCIRLoadOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLoadOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());

  mlir::UnitAttr is_derefDeser;
  if (pOp.has_is_deref()) {
    auto elem = pOp.is_deref();
    is_derefDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::IntegerAttr alignmentDeser;
  if (pOp.has_alignment()) {
    auto elem = pOp.alignment();
    alignmentDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, elem);
  }

  cir::MemOrderAttr mem_orderDeser;
  if (pOp.has_mem_order()) {
    auto elem = pOp.mem_order();
    mem_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(elem));
  }

  mlir::ArrayAttr tbaaDeser;
  if (pOp.has_tbaa()) {
    auto elem = pOp.tbaa();
    tbaaDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::LoadOp>(mInfo.builder.getUnknownLoc(), resultDeser, addrDeser, is_derefDeser, is_volatileDeser, alignmentDeser, mem_orderDeser, tbaaDeser);
}

cir::Log10Op OpDeserializer::deserializeCIRLog10Op(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLog10Op pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::Log10Op>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::Log2Op OpDeserializer::deserializeCIRLog2Op(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLog2Op pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::Log2Op>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::LogOp OpDeserializer::deserializeCIRLogOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLogOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::LogOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::LrintOp OpDeserializer::deserializeCIRLrintOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLrintOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::LrintOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::LroundOp OpDeserializer::deserializeCIRLroundOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRLroundOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::LroundOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::MemChrOp OpDeserializer::deserializeCIRMemChrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemChrOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto patternDeser = Deserializer::deserializeValue(fInfo, pOp.pattern());
  auto lenDeser = Deserializer::deserializeValue(fInfo, pOp.len());
  return mInfo.builder.create<cir::MemChrOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser, patternDeser, lenDeser);
}

cir::MemCpyInlineOp OpDeserializer::deserializeCIRMemCpyInlineOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemCpyInlineOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto lenDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.len());
  return mInfo.builder.create<cir::MemCpyInlineOp>(mInfo.builder.getUnknownLoc(), dstDeser, srcDeser, lenDeser);
}

cir::MemCpyOp OpDeserializer::deserializeCIRMemCpyOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemCpyOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto lenDeser = Deserializer::deserializeValue(fInfo, pOp.len());
  return mInfo.builder.create<cir::MemCpyOp>(mInfo.builder.getUnknownLoc(), dstDeser, srcDeser, lenDeser);
}

cir::MemMoveOp OpDeserializer::deserializeCIRMemMoveOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemMoveOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto lenDeser = Deserializer::deserializeValue(fInfo, pOp.len());
  return mInfo.builder.create<cir::MemMoveOp>(mInfo.builder.getUnknownLoc(), dstDeser, srcDeser, lenDeser);
}

cir::MemSetInlineOp OpDeserializer::deserializeCIRMemSetInlineOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemSetInlineOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  auto lenDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.len());
  return mInfo.builder.create<cir::MemSetInlineOp>(mInfo.builder.getUnknownLoc(), dstDeser, valDeser, lenDeser);
}

cir::MemSetOp OpDeserializer::deserializeCIRMemSetOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRMemSetOp pOp) {
  auto dstDeser = Deserializer::deserializeValue(fInfo, pOp.dst());
  auto valDeser = Deserializer::deserializeValue(fInfo, pOp.val());
  auto lenDeser = Deserializer::deserializeValue(fInfo, pOp.len());
  return mInfo.builder.create<cir::MemSetOp>(mInfo.builder.getUnknownLoc(), dstDeser, valDeser, lenDeser);
}

cir::NearbyintOp OpDeserializer::deserializeCIRNearbyintOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRNearbyintOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::NearbyintOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ObjSizeOp OpDeserializer::deserializeCIRObjSizeOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRObjSizeOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  auto kindDeser = cir::SizeInfoTypeAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRSizeInfoType(pOp.kind()));

  mlir::UnitAttr dynamicDeser;
  if (pOp.has_dynamic()) {
    auto elem = pOp.dynamic();
    dynamicDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ObjSizeOp>(mInfo.builder.getUnknownLoc(), resultDeser, ptrDeser, kindDeser, dynamicDeser);
}

cir::PowOp OpDeserializer::deserializeCIRPowOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRPowOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::PowOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::PrefetchOp OpDeserializer::deserializeCIRPrefetchOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRPrefetchOp pOp) {
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  auto localityDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.locality());

  mlir::UnitAttr is_writeDeser;
  if (pOp.has_is_write()) {
    auto elem = pOp.is_write();
    is_writeDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::PrefetchOp>(mInfo.builder.getUnknownLoc(), addrDeser, localityDeser, is_writeDeser);
}

cir::PtrDiffOp OpDeserializer::deserializeCIRPtrDiffOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRPtrDiffOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::PtrDiffOp>(mInfo.builder.getUnknownLoc(), resultDeser, lhsDeser, rhsDeser);
}

cir::PtrMaskOp OpDeserializer::deserializeCIRPtrMaskOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRPtrMaskOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  auto maskDeser = Deserializer::deserializeValue(fInfo, pOp.mask());
  return mInfo.builder.create<cir::PtrMaskOp>(mInfo.builder.getUnknownLoc(), resultDeser, ptrDeser, maskDeser);
}

cir::PtrStrideOp OpDeserializer::deserializeCIRPtrStrideOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRPtrStrideOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto baseDeser = Deserializer::deserializeValue(fInfo, pOp.base());
  auto strideDeser = Deserializer::deserializeValue(fInfo, pOp.stride());
  return mInfo.builder.create<cir::PtrStrideOp>(mInfo.builder.getUnknownLoc(), resultDeser, baseDeser, strideDeser);
}

cir::ResumeOp OpDeserializer::deserializeCIRResumeOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRResumeOp pOp) {
  mlir::Value exception_ptrDeser;
  if (pOp.has_exception_ptr()) {
    auto elem = pOp.exception_ptr();
    exception_ptrDeser = Deserializer::deserializeValue(fInfo, elem);
  }

  mlir::Value type_idDeser;
  if (pOp.has_type_id()) {
    auto elem = pOp.type_id();
    type_idDeser = Deserializer::deserializeValue(fInfo, elem);
  }

  mlir::UnitAttr rethrowDeser;
  if (pOp.has_rethrow()) {
    auto elem = pOp.rethrow();
    rethrowDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ResumeOp>(mInfo.builder.getUnknownLoc(), exception_ptrDeser, type_idDeser, rethrowDeser);
}

cir::ReturnAddrOp OpDeserializer::deserializeCIRReturnAddrOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRReturnAddrOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto levelDeser = Deserializer::deserializeValue(fInfo, pOp.level());
  return mInfo.builder.create<cir::ReturnAddrOp>(mInfo.builder.getUnknownLoc(), resultDeser, levelDeser);
}

cir::ReturnOp OpDeserializer::deserializeCIRReturnOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRReturnOp pOp) {
  std::vector<mlir::Value> inputDeser;
  for (auto i = 0; i < pOp.input_size(); i++) {
    auto elem = pOp.input(i);
    inputDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  return mInfo.builder.create<cir::ReturnOp>(mInfo.builder.getUnknownLoc(), inputDeser);
}

cir::RintOp OpDeserializer::deserializeCIRRintOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRRintOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::RintOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::RotateOp OpDeserializer::deserializeCIRRotateOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRRotateOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto amtDeser = Deserializer::deserializeValue(fInfo, pOp.amt());

  mlir::UnitAttr leftDeser;
  if (pOp.has_left()) {
    auto elem = pOp.left();
    leftDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::RotateOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser, amtDeser, leftDeser);
}

cir::RoundOp OpDeserializer::deserializeCIRRoundOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRRoundOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::RoundOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::ScopeOp OpDeserializer::deserializeCIRScopeOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRScopeOp pOp) {
  mlir::Type resultsDeser;
  if (pOp.has_results()) {
    auto elem = pOp.results();
    resultsDeser = Deserializer::getType(mInfo, elem);
  }
  return mInfo.builder.create<cir::ScopeOp>(mInfo.builder.getUnknownLoc(), resultsDeser);
}

cir::SelectOp OpDeserializer::deserializeCIRSelectOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSelectOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto conditionDeser = Deserializer::deserializeValue(fInfo, pOp.condition());
  auto true_valueDeser = Deserializer::deserializeValue(fInfo, pOp.true_value());
  auto false_valueDeser = Deserializer::deserializeValue(fInfo, pOp.false_value());
  return mInfo.builder.create<cir::SelectOp>(mInfo.builder.getUnknownLoc(), resultDeser, conditionDeser, true_valueDeser, false_valueDeser);
}

cir::SetBitfieldOp OpDeserializer::deserializeCIRSetBitfieldOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSetBitfieldOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  auto bitfield_infoDeser = AttrDeserializer::deserializeCIRBitfieldInfoAttr(mInfo, pOp.bitfield_info());

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::SetBitfieldOp>(mInfo.builder.getUnknownLoc(), resultDeser, addrDeser, srcDeser, bitfield_infoDeser, is_volatileDeser);
}

cir::ShiftOp OpDeserializer::deserializeCIRShiftOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRShiftOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto valueDeser = Deserializer::deserializeValue(fInfo, pOp.value());
  auto amountDeser = Deserializer::deserializeValue(fInfo, pOp.amount());

  mlir::UnitAttr is_shiftleftDeser;
  if (pOp.has_is_shiftleft()) {
    auto elem = pOp.is_shiftleft();
    is_shiftleftDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ShiftOp>(mInfo.builder.getUnknownLoc(), resultDeser, valueDeser, amountDeser, is_shiftleftDeser);
}

cir::SignBitOp OpDeserializer::deserializeCIRSignBitOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSignBitOp pOp) {
  auto resDeser = Deserializer::getType(mInfo, pOp.res());
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::SignBitOp>(mInfo.builder.getUnknownLoc(), resDeser, inputDeser);
}

cir::SinOp OpDeserializer::deserializeCIRSinOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSinOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::SinOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::SqrtOp OpDeserializer::deserializeCIRSqrtOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSqrtOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::SqrtOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::StackRestoreOp OpDeserializer::deserializeCIRStackRestoreOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRStackRestoreOp pOp) {
  auto ptrDeser = Deserializer::deserializeValue(fInfo, pOp.ptr());
  return mInfo.builder.create<cir::StackRestoreOp>(mInfo.builder.getUnknownLoc(), ptrDeser);
}

cir::StackSaveOp OpDeserializer::deserializeCIRStackSaveOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRStackSaveOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  return mInfo.builder.create<cir::StackSaveOp>(mInfo.builder.getUnknownLoc(), resultDeser);
}

cir::StdFindOp OpDeserializer::deserializeCIRStdFindOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRStdFindOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto original_fnDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, pOp.original_fn());
  auto firstDeser = Deserializer::deserializeValue(fInfo, pOp.first());
  auto lastDeser = Deserializer::deserializeValue(fInfo, pOp.last());
  auto patternDeser = Deserializer::deserializeValue(fInfo, pOp.pattern());
  return mInfo.builder.create<cir::StdFindOp>(mInfo.builder.getUnknownLoc(), resultDeser, original_fnDeser, firstDeser, lastDeser, patternDeser);
}

cir::StdInitializerListOp OpDeserializer::deserializeCIRStdInitializerListOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRStdInitializerListOp pOp) {
  auto initListDeser = Deserializer::deserializeValue(fInfo, pOp.init_list());

  std::vector<mlir::Value> argsDeser;
  for (auto i = 0; i < pOp.args_size(); i++) {
    auto elem = pOp.args(i);
    argsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  return mInfo.builder.create<cir::StdInitializerListOp>(mInfo.builder.getUnknownLoc(), initListDeser, argsDeser);
}

cir::StoreOp OpDeserializer::deserializeCIRStoreOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRStoreOp pOp) {
  auto valueDeser = Deserializer::deserializeValue(fInfo, pOp.value());
  auto addrDeser = Deserializer::deserializeValue(fInfo, pOp.addr());

  mlir::UnitAttr is_volatileDeser;
  if (pOp.has_is_volatile()) {
    auto elem = pOp.is_volatile();
    is_volatileDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::IntegerAttr alignmentDeser;
  if (pOp.has_alignment()) {
    auto elem = pOp.alignment();
    alignmentDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, elem);
  }

  cir::MemOrderAttr mem_orderDeser;
  if (pOp.has_mem_order()) {
    auto elem = pOp.mem_order();
    mem_orderDeser = cir::MemOrderAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRMemOrder(elem));
  }

  mlir::ArrayAttr tbaaDeser;
  if (pOp.has_tbaa()) {
    auto elem = pOp.tbaa();
    tbaaDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::StoreOp>(mInfo.builder.getUnknownLoc(), valueDeser, addrDeser, is_volatileDeser, alignmentDeser, mem_orderDeser, tbaaDeser);
}

cir::SwitchFlatOp OpDeserializer::deserializeCIRSwitchFlatOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSwitchFlatOp pOp) {
  auto conditionDeser = Deserializer::deserializeValue(fInfo, pOp.condition());

  std::vector<mlir::Value> defaultOperandsDeser;
  for (auto i = 0; i < pOp.default_operands_size(); i++) {
    auto elem = pOp.default_operands(i);
    defaultOperandsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }

  std::vector<mlir::ValueRange> caseOperandsDeser;
  for (auto j = 0; j < pOp.case_operands_size(); j++) {std::vector<mlir::Value> pOpInner;
    for (auto i = 0; i < pOp.case_operands(j).list_size(); i++) {
      auto elem = pOp.case_operands(j).list(i);
      pOpInner.push_back(Deserializer::deserializeValue(fInfo, elem));
    }

    caseOperandsDeser.push_back(pOpInner);
  }
  auto case_valuesDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pOp.case_values());
  auto defaultDestinationDeser = Deserializer::getBlock(fInfo, pOp.default_destination());

  std::vector<mlir::Block *> caseDestinationsDeser;
  for (auto i = 0; i < pOp.case_destinations_size(); i++) {
    auto elem = pOp.case_destinations(i);
    caseDestinationsDeser.push_back(Deserializer::getBlock(fInfo, elem));
  }
  return mInfo.builder.create<cir::SwitchFlatOp>(mInfo.builder.getUnknownLoc(), conditionDeser, defaultOperandsDeser, caseOperandsDeser, case_valuesDeser, defaultDestinationDeser, caseDestinationsDeser);
}

cir::SwitchOp OpDeserializer::deserializeCIRSwitchOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRSwitchOp pOp) {
  auto conditionDeser = Deserializer::deserializeValue(fInfo, pOp.condition());
  return mInfo.builder.create<cir::SwitchOp>(mInfo.builder.getUnknownLoc(), conditionDeser);
}

cir::TernaryOp OpDeserializer::deserializeCIRTernaryOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRTernaryOp pOp) {
  mlir::Type resultDeser;
  if (pOp.has_result()) {
    auto elem = pOp.result();
    resultDeser = Deserializer::getType(mInfo, elem);
  }
  auto condDeser = Deserializer::deserializeValue(fInfo, pOp.cond());
  return mInfo.builder.create<cir::TernaryOp>(mInfo.builder.getUnknownLoc(), resultDeser, condDeser);
}

cir::ThrowOp OpDeserializer::deserializeCIRThrowOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRThrowOp pOp) {
  mlir::Value exception_ptrDeser;
  if (pOp.has_exception_ptr()) {
    auto elem = pOp.exception_ptr();
    exception_ptrDeser = Deserializer::deserializeValue(fInfo, elem);
  }

  mlir::FlatSymbolRefAttr type_infoDeser;
  if (pOp.has_type_info()) {
    auto elem = pOp.type_info();
    type_infoDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  mlir::FlatSymbolRefAttr dtorDeser;
  if (pOp.has_dtor()) {
    auto elem = pOp.dtor();
    dtorDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::ThrowOp>(mInfo.builder.getUnknownLoc(), exception_ptrDeser, type_infoDeser, dtorDeser);
}

cir::TrapOp OpDeserializer::deserializeCIRTrapOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRTrapOp pOp) {
  return mInfo.builder.create<cir::TrapOp>(mInfo.builder.getUnknownLoc());
}

cir::TruncOp OpDeserializer::deserializeCIRTruncOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRTruncOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto srcDeser = Deserializer::deserializeValue(fInfo, pOp.src());
  return mInfo.builder.create<cir::TruncOp>(mInfo.builder.getUnknownLoc(), resultDeser, srcDeser);
}

cir::TryCallOp OpDeserializer::deserializeCIRTryCallOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRTryCallOp pOp) {
  mlir::Type resultDeser;
  if (pOp.has_result()) {
    auto elem = pOp.result();
    resultDeser = Deserializer::getType(mInfo, elem);
  }

  std::vector<mlir::Value> contOperandsDeser;
  for (auto i = 0; i < pOp.cont_operands_size(); i++) {
    auto elem = pOp.cont_operands(i);
    contOperandsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }

  std::vector<mlir::Value> landingPadOperandsDeser;
  for (auto i = 0; i < pOp.landing_pad_operands_size(); i++) {
    auto elem = pOp.landing_pad_operands(i);
    landingPadOperandsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }

  mlir::FlatSymbolRefAttr calleeDeser;
  if (pOp.has_callee()) {
    auto elem = pOp.callee();
    calleeDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  std::vector<mlir::Value> arg_opsDeser;
  for (auto i = 0; i < pOp.arg_ops_size(); i++) {
    auto elem = pOp.arg_ops(i);
    arg_opsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  auto calling_convDeser = cir::CallingConvAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCallingConv(pOp.calling_conv()));
  auto extra_attrsDeser = AttrDeserializer::deserializeCIRExtraFuncAttributesAttr(mInfo, pOp.extra_attrs());
  cir::ASTCallExprInterface astDeser;
  auto contDeser = Deserializer::getBlock(fInfo, pOp.cont());
  auto landing_padDeser = Deserializer::getBlock(fInfo, pOp.landing_pad());
  return mInfo.builder.create<cir::TryCallOp>(mInfo.builder.getUnknownLoc(), resultDeser, contOperandsDeser, landingPadOperandsDeser, calleeDeser, arg_opsDeser, calling_convDeser, extra_attrsDeser, astDeser, contDeser, landing_padDeser);
}

cir::TryOp OpDeserializer::deserializeCIRTryOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRTryOp pOp) {
  mlir::UnitAttr syntheticDeser;
  if (pOp.has_synthetic()) {
    auto elem = pOp.synthetic();
    syntheticDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::UnitAttr cleanupDeser;
  if (pOp.has_cleanup()) {
    auto elem = pOp.cleanup();
    cleanupDeser = AttrDeserializer::deserializeMLIRUnitAttr(mInfo, elem);
  }

  mlir::ArrayAttr catch_typesDeser;
  if (pOp.has_catch_types()) {
    auto elem = pOp.catch_types();
    catch_typesDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, elem);
  }
  return mInfo.builder.create<cir::TryOp>(mInfo.builder.getUnknownLoc(), syntheticDeser, cleanupDeser, catch_typesDeser, 0);
}

cir::UnaryOp OpDeserializer::deserializeCIRUnaryOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRUnaryOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::UnaryOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRUnaryOpKind(pOp.kind()));
  auto inputDeser = Deserializer::deserializeValue(fInfo, pOp.input());
  return mInfo.builder.create<cir::UnaryOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, inputDeser);
}

cir::UnreachableOp OpDeserializer::deserializeCIRUnreachableOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRUnreachableOp pOp) {
  return mInfo.builder.create<cir::UnreachableOp>(mInfo.builder.getUnknownLoc());
}

cir::VAArgOp OpDeserializer::deserializeCIRVAArgOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVAArgOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto arg_listDeser = Deserializer::deserializeValue(fInfo, pOp.arg_list());
  return mInfo.builder.create<cir::VAArgOp>(mInfo.builder.getUnknownLoc(), resultDeser, arg_listDeser);
}

cir::VACopyOp OpDeserializer::deserializeCIRVACopyOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVACopyOp pOp) {
  auto dst_listDeser = Deserializer::deserializeValue(fInfo, pOp.dst_list());
  auto src_listDeser = Deserializer::deserializeValue(fInfo, pOp.src_list());
  return mInfo.builder.create<cir::VACopyOp>(mInfo.builder.getUnknownLoc(), dst_listDeser, src_listDeser);
}

cir::VAEndOp OpDeserializer::deserializeCIRVAEndOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVAEndOp pOp) {
  auto arg_listDeser = Deserializer::deserializeValue(fInfo, pOp.arg_list());
  return mInfo.builder.create<cir::VAEndOp>(mInfo.builder.getUnknownLoc(), arg_listDeser);
}

cir::VAStartOp OpDeserializer::deserializeCIRVAStartOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVAStartOp pOp) {
  auto arg_listDeser = Deserializer::deserializeValue(fInfo, pOp.arg_list());
  return mInfo.builder.create<cir::VAStartOp>(mInfo.builder.getUnknownLoc(), arg_listDeser);
}

cir::VTTAddrPointOp OpDeserializer::deserializeCIRVTTAddrPointOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVTTAddrPointOp pOp) {
  auto addrDeser = Deserializer::getType(mInfo, pOp.addr());

  mlir::FlatSymbolRefAttr nameDeser;
  if (pOp.has_name()) {
    auto elem = pOp.name();
    nameDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  mlir::Value sym_addrDeser;
  if (pOp.has_sym_addr()) {
    auto elem = pOp.sym_addr();
    sym_addrDeser = Deserializer::deserializeValue(fInfo, elem);
  }
  auto offsetDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.offset());
  return mInfo.builder.create<cir::VTTAddrPointOp>(mInfo.builder.getUnknownLoc(), addrDeser, nameDeser, sym_addrDeser, offsetDeser);
}

cir::VTableAddrPointOp OpDeserializer::deserializeCIRVTableAddrPointOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVTableAddrPointOp pOp) {
  auto addrDeser = Deserializer::getType(mInfo, pOp.addr());

  mlir::FlatSymbolRefAttr nameDeser;
  if (pOp.has_name()) {
    auto elem = pOp.name();
    nameDeser = AttrDeserializer::deserializeMLIRFlatSymbolRefAttr(mInfo, elem);
  }

  mlir::Value sym_addrDeser;
  if (pOp.has_sym_addr()) {
    auto elem = pOp.sym_addr();
    sym_addrDeser = Deserializer::deserializeValue(fInfo, elem);
  }
  auto vtable_indexDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.vtable_index());
  auto address_point_indexDeser = AttrDeserializer::deserializeMLIRIntegerAttr(mInfo, pOp.address_point_index());
  return mInfo.builder.create<cir::VTableAddrPointOp>(mInfo.builder.getUnknownLoc(), addrDeser, nameDeser, sym_addrDeser, vtable_indexDeser, address_point_indexDeser);
}

cir::VecCmpOp OpDeserializer::deserializeCIRVecCmpOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecCmpOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto kindDeser = cir::CmpOpKindAttr::get(&mInfo.ctx, EnumDeserializer::deserializeCIRCmpOpKind(pOp.kind()));
  auto lhsDeser = Deserializer::deserializeValue(fInfo, pOp.lhs());
  auto rhsDeser = Deserializer::deserializeValue(fInfo, pOp.rhs());
  return mInfo.builder.create<cir::VecCmpOp>(mInfo.builder.getUnknownLoc(), resultDeser, kindDeser, lhsDeser, rhsDeser);
}

cir::VecCreateOp OpDeserializer::deserializeCIRVecCreateOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecCreateOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());

  std::vector<mlir::Value> elementsDeser;
  for (auto i = 0; i < pOp.elements_size(); i++) {
    auto elem = pOp.elements(i);
    elementsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  return mInfo.builder.create<cir::VecCreateOp>(mInfo.builder.getUnknownLoc(), resultDeser, elementsDeser);
}

cir::VecExtractOp OpDeserializer::deserializeCIRVecExtractOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecExtractOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto vecDeser = Deserializer::deserializeValue(fInfo, pOp.vec());
  auto indexDeser = Deserializer::deserializeValue(fInfo, pOp.index());
  return mInfo.builder.create<cir::VecExtractOp>(mInfo.builder.getUnknownLoc(), resultDeser, vecDeser, indexDeser);
}

cir::VecInsertOp OpDeserializer::deserializeCIRVecInsertOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecInsertOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto vecDeser = Deserializer::deserializeValue(fInfo, pOp.vec());
  auto valueDeser = Deserializer::deserializeValue(fInfo, pOp.value());
  auto indexDeser = Deserializer::deserializeValue(fInfo, pOp.index());
  return mInfo.builder.create<cir::VecInsertOp>(mInfo.builder.getUnknownLoc(), resultDeser, vecDeser, valueDeser, indexDeser);
}

cir::VecShuffleDynamicOp OpDeserializer::deserializeCIRVecShuffleDynamicOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecShuffleDynamicOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto vecDeser = Deserializer::deserializeValue(fInfo, pOp.vec());
  auto indicesDeser = Deserializer::deserializeValue(fInfo, pOp.indices());
  return mInfo.builder.create<cir::VecShuffleDynamicOp>(mInfo.builder.getUnknownLoc(), resultDeser, vecDeser, indicesDeser);
}

cir::VecShuffleOp OpDeserializer::deserializeCIRVecShuffleOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecShuffleOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto vec1Deser = Deserializer::deserializeValue(fInfo, pOp.vec1());
  auto vec2Deser = Deserializer::deserializeValue(fInfo, pOp.vec2());
  auto indicesDeser = AttrDeserializer::deserializeMLIRArrayAttr(mInfo, pOp.indices());
  return mInfo.builder.create<cir::VecShuffleOp>(mInfo.builder.getUnknownLoc(), resultDeser, vec1Deser, vec2Deser, indicesDeser);
}

cir::VecSplatOp OpDeserializer::deserializeCIRVecSplatOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecSplatOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto valueDeser = Deserializer::deserializeValue(fInfo, pOp.value());
  return mInfo.builder.create<cir::VecSplatOp>(mInfo.builder.getUnknownLoc(), resultDeser, valueDeser);
}

cir::VecTernaryOp OpDeserializer::deserializeCIRVecTernaryOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRVecTernaryOp pOp) {
  auto resultDeser = Deserializer::getType(mInfo, pOp.result());
  auto condDeser = Deserializer::deserializeValue(fInfo, pOp.cond());
  auto vec1Deser = Deserializer::deserializeValue(fInfo, pOp.vec1());
  auto vec2Deser = Deserializer::deserializeValue(fInfo, pOp.vec2());
  return mInfo.builder.create<cir::VecTernaryOp>(mInfo.builder.getUnknownLoc(), resultDeser, condDeser, vec1Deser, vec2Deser);
}

cir::WhileOp OpDeserializer::deserializeCIRWhileOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRWhileOp pOp) {
  return mInfo.builder.create<cir::WhileOp>(mInfo.builder.getUnknownLoc());
}

cir::YieldOp OpDeserializer::deserializeCIRYieldOp(FunctionInfo &fInfo, ModuleInfo &mInfo, CIRYieldOp pOp) {
  std::vector<mlir::Value> argsDeser;
  for (auto i = 0; i < pOp.args_size(); i++) {
    auto elem = pOp.args(i);
    argsDeser.push_back(Deserializer::deserializeValue(fInfo, elem));
  }
  return mInfo.builder.create<cir::YieldOp>(mInfo.builder.getUnknownLoc(), argsDeser);
}


// clang-format on
